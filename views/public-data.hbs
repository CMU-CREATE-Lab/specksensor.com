<link href="/css/grapher.css" rel="stylesheet" type="text/css"/>
<link href="/lib/cal-heatmap/cal-heatmap.css" rel="stylesheet" type="text/css"/>
<script src="https://maps.googleapis.com/maps/api/js?key={{{googleMapsApiKey}}}&libraries=geometry" type="text/javascript"></script>
<script src="/lib/canvas-layer/src/CanvasLayer.js" type="text/javascript"></script>
<script src="/js/com/specksensor/geo/Map.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/jquery-mousewheel/jquery.mousewheel.min.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/createlab-grapher/grapher.min.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/plot-manager/org/bodytrack/grapher/PlotManager.js" type="text/javascript"></script>
<script src="/lib/nimble/nimble.min.js" type="text/javascript"></script>
<script src="/lib/d3/d3.min.js" type="text/javascript"></script>
<script src="/lib/cal-heatmap/cal-heatmap.min.js" type="text/javascript"></script>

<script language="JavaScript" type="text/javascript">
   // hardcode these to production since dev/test/stage don't have enough data to be interesting
   var ESDR_API_ROOT_URL = 'https://esdr.cmucreatelab.org/api/v1';
   var PRODUCT_ID = 9;

   var ESDR_QUERY_ITEM_LIMIT = 1000;

   var DEFAULT_CHANNEL_NAMES = [
      "particle_count",
      "particle_concentration",
      "PM2_5",
      "PM25B_UG_M3",
      "PM25_2__UG_M3",
      "PM25_UG_M3"
   ];

   var GOVT_PM_2_5_CHANNEL_NAMES = [
      "PM2_5",
      "PM25B_UG_M3",
      "PM25_2__UG_M3",
      "PM25_UG_M3"
   ];

   var DAILY_STATS_CHANNEL_NAME_SUFFIXES = [
      "_daily_mean",
      "_daily_median",
      "_daily_max"
   ];

   var SEVEN_DAYS_IN_SECS = 604800;

   var EXTRA_SMALL_DEVICE_WIDTH_PIXELS = 629;

   // map and marker rendering
   var MAP_CENTER = new google.maps.LatLng(18.154407669746245, -60.99310273040771);
   var SELECTED_MARKER_COLOR = "#ff0000";
   var MARKER_RADIUS = 5;
   var TWO_PI = 2 * Math.PI;

   // look within a bounding box with radius of 40 km around geocoded location
   var SEARCH_RADIUS_IN_KM = 40;
   // when geocoding, ignore govt feeds which have a PM2.5 feed which hasn't been updated within the past 4 hours
   var FOUR_HOURS_IN_SECONDS = 4 * 60 * 60;

   // grapher stuff
   var plotManager;
   var currentDateAxisRange = { min : null, max : null };
   var lastDateAxisChangeEventMillis = null;

   // map stuff
   var map = new com.specksensor.geo.Map("map_area");
   var geocodedLocationMarker = null;

   var govtFeeds = [];
   var govtFeedsById = {};
   var govtRecentValuesByFeedId = {};
   var speckFeeds = { indoor : [], outdoor : [] };
   var speckFeedsById = { indoor : {}, outdoor : {} };
   var feedsById = {};
   var selectedFeed = null;
   var selectedChannelName = DEFAULT_CHANNEL_NAMES[0];
   var cal = null;

   var dailyStatsCalendarAndTableTemplate = Handlebars.templates['daily_stats_calendar_and_table'];

   var statsDataByChannel = {};

   // stole this (with slight modification) from http://jsfiddle.net/mpetrovich/wMmHS/
   Handlebars.registerHelper("math", function(lvalue, operator, rvalue, numDecimalPlaces) {
      lvalue = parseFloat(lvalue);
      rvalue = parseFloat(rvalue);

      var result = {
         "+" : lvalue + rvalue,
         "-" : lvalue - rvalue,
         "*" : lvalue * rvalue,
         "/" : lvalue / rvalue,
         "%" : lvalue % rvalue
      }[operator];

      numDecimalPlaces = parseInt(numDecimalPlaces);
      if (isNaN(numDecimalPlaces) || numDecimalPlaces < 0) {
         numDecimalPlaces = 0;
      }

      return result.toFixed(numDecimalPlaces);
   });

   function getHashParam(paramName) {
      var hash = window.location.hash.substr(1);
      if (hash == '') {
         return null;
      }

      var hashParts = hash.split('&');
      for (var i = 0; i < hashParts.length; ++i) {
         var keyAndVal = hashParts[i].split('=');
         if (keyAndVal.length != 2) {
            continue;
         }
         if (keyAndVal[0] == paramName) {
            return decodeURIComponent(keyAndVal[1].replace(/\+/g, " "));
         }
      }
      return "";
   }

   function getDefaultMapZoomLevel() {
      return $(window).width() < 600 ? 1 : 2;   // zoom out more for small screens
   }

   // make the height a little smaller when on a screen with a smallish width
   function adjustMapHeightForSmallScreens() {
      //if ($(window).width() < 600) {
      //   map.setHeight(400);
      //}
   }

   window.grapherLoad = function() {
      window.onhashchange = handleGeocode;

      map.initialize(
            {
               center : MAP_CENTER,
               zoom : getDefaultMapZoomLevel(),
               styles : [
                  {
                     featureType : "poi",
                     elementType : "labels",
                     stylers : [
                        { visibility : "off" }
                     ]
                  }
               ]
            },
            {
               searchDistanceFromMarkerInPixels : MARKER_RADIUS
            },
            {
               handleInitializationComplete : function() {
                  _.parallel(
                        [
                           function(done) {
                              loadGovtFeeds(0, done);
                           },
                           function(done) {
                              loadSpeckFeeds(0, done);
                           },
                           function(done) {
                              loadRecentGovtData(0, done);
                           }
                        ],
                        function(err) {
                           if (err) {
                              // TODO
                              console.log("Failed to load feeds: " + err);
                           }
                           else {
                              // shrink map height when on a screen with a smallish width
                              adjustMapHeightForSmallScreens();

                              console.log("Done loading feeds: [" + govtFeeds.length + "] regulated, [" + (speckFeeds.indoor.length + speckFeeds.outdoor.length) + "] speck");

                              initializeGrapher();
                              initializeMarkers();
                              map.renderMarkers();

                              handleGeocode();
                           }
                        });
               },
               handleMarkerSelected : function(marker, nearbyMarkers) {
                  // TODO show a popup with all matching markers
                  setFeedSelected(marker.id);
               },
               onBeforeRenderMarkers : function(context) {
                  // calculate and remember feed filter states before rendering, since rendering of each marker needs
                  // to check these states to see whether to draw the marker
                  return {
                     willShowGovtFeeds : $("#govt_feed_checkbox")[0].checked,
                     willShowIndoorSpeckFeeds : $("#indoor_speck_checkbox")[0].checked,
                     willShowOutdoorSpeckFeeds : $("#outdoor_speck_checkbox")[0].checked
                  };
               },
               onAfterRenderMarkers : function(context) {
                  // render the highlight around the selected marker (if any).  We do this last, in onAfterRenderMarkers,
                  // to ensure the highlight appears on top of all the markers
                  if (selectedFeed) {
                     var selectedMarker = map.getMarkerById(selectedFeed.id);
                     var markerCanvasPosition = map.worldPointToCanvasPixelCoords(selectedMarker.worldPoint);
                     var radius = MARKER_RADIUS + 1;
                     context.beginPath();
                     context.lineWidth = 2;
                     context.strokeStyle = SELECTED_MARKER_COLOR;
                     if (selectedFeed.id in govtFeedsById) {
                        // draw a square
                        context.rect(markerCanvasPosition.x - radius,
                                     markerCanvasPosition.y - radius,
                                     2 * radius,
                                     2 * radius);
                     }
                     else {
                        // draw a circle
                        context.arc(markerCanvasPosition.x,
                                    markerCanvasPosition.y,
                                    radius,
                                    0,
                                    TWO_PI,
                                    false);
                     }
                     context.stroke();
                  }
               }
            }
      );
   };

   /*
            var isGovtFeed = marker.id in govtFeedsById;

         context.beginPath();
         if (isGovtFeed) {
            // draw a square
            context.fillStyle = getGovtMarkerColor(govtRecentValuesByFeedId[marker.id]);
         }
         else {
            // draw a circle
            context.arc(canvasPosition.x, canvasPosition.y, MARKER_RADIUS, 0, TWO_PI, false);
            context.fillStyle = "rgba(10, 10, 10, 0.6)";
         }

    */
   function handleGeocode() {
      var location = getHashParam('loc');
      if (typeof location !== 'undefined' && location != null && location.length > 0) {
         $(".geocode_location").val(location);
         geocodeAddress(location);
      }
   }

   function loadSpeckFeeds(page, done) {
      var offset = ESDR_QUERY_ITEM_LIMIT * page;

      // load the Speck feeds (public feeds, having data, and with lat/long defined)
      superagent
            .get(ESDR_API_ROOT_URL + "/feeds?where=productId=" + PRODUCT_ID + ",maxTimeSecs<>__NULL__,latitude<>__NULL__,longitude<>__NULL__&fields=id,name,latitude,longitude,minTimeSecs,maxTimeSecs,channelBounds,channelSpecs,exposure&orderBy=id&limit=" + ESDR_QUERY_ITEM_LIMIT + "&offset=" + offset)
            .end(function(err, res) {
               if (err) {
                  done(err);
               }
               else {
                  // got the data
                  if (res.body.code == 200 &&
                      typeof res.body.data !== 'undefined' &&
                      res.body.data != null) {

                     // concatenate the new rows, separating indoor and outdoor
                     Array.prototype.push.apply(speckFeeds.indoor, res.body.data.rows.filter(function(feed) {
                        return feed.exposure == 'indoor';
                     }));
                     Array.prototype.push.apply(speckFeeds.outdoor, res.body.data.rows.filter(function(feed) {
                        return feed.exposure == 'outdoor';
                     }));

                     // see whether we need to load more
                     if ((speckFeeds.indoor.length + speckFeeds.outdoor.length) < res.body.data.totalCount) {
                        loadSpeckFeeds(++page, done);
                     }
                     else {
                        done();
                     }
                  }
                  else {
                     done(new Error("Failed to load speck feeds: " + JSON.stringify(res.body, null, 3)));
                  }
               }
            });
   }

   function loadGovtFeeds(page, done) {
      var offset = ESDR_QUERY_ITEM_LIMIT * page;

      superagent
            .get(ESDR_API_ROOT_URL + "/multifeeds/pm_2_5/feeds?fields=id,name,latitude,longitude,minTimeSecs,maxTimeSecs,channelBounds,channelSpecs&orderBy=id&limit=" + ESDR_QUERY_ITEM_LIMIT + "&offset=" + offset)
            .end(function(err, res) {
               if (err) {
                  done(err);
               }
               else {
                  // got the data
                  if (res.body.code == 200 &&
                      typeof res.body.data !== 'undefined' &&
                      res.body.data != null) {

                     // create a google.maps.LatLng for each feed, for easy bounds containment checking later
                     res.body.data.rows.forEach(function(feed) {
                        feed.latLng = new google.maps.LatLng(feed.latitude, feed.longitude);
                     });

                     // concatenate the new rows
                     Array.prototype.push.apply(govtFeeds, res.body.data.rows);

                     // see whether we need to load more
                     if (govtFeeds.length < res.body.data.totalCount) {
                        loadGovtFeeds(++page, done);
                     }
                     else {
                        done();
                     }
                  }
                  else {
                     done(new Error("Failed to load govt feeds: " + JSON.stringify(res.body, null, 3)));
                  }
               }
            });
   }

   function loadRecentGovtData(page, done) {
      var offset = ESDR_QUERY_ITEM_LIMIT * page;

      superagent
            .get("/api/v1/pm-stations?fields=feedId,recentValue&where=recentValue<>__NULL__&orderBy=feedId&limit=" + ESDR_QUERY_ITEM_LIMIT + "&offset=" + offset)
            .end(function(err, res) {
               if (err) {
                  done(err);
               }
               else {
                  // got the data
                  if (res.body.code == 200 &&
                      typeof res.body.data !== 'undefined' &&
                      res.body.data != null) {

                     // insert the new rows into the map
                     for (var i = 0; i < res.body.data.rows.length; i++) {
                        var row = res.body.data.rows[i];
                        govtRecentValuesByFeedId[row.feedId] = row.recentValue;
                     }

                     // see whether we need to load more
                     if (Object.keys(govtRecentValuesByFeedId).length < res.body.data.totalCount) {
                        loadRecentGovtData(++page, done);
                     }
                     else {
                        done();
                     }
                  }
                  else {
                     done(new Error("Failed to load recent data for govt feeds: " + JSON.stringify(res.body, null, 3)));
                  }
               }
            });
   }

   function getDesiredPlotManagerSize() {
      return $("#grapher_container").width()    // grapher container width
             - $(".y_axis").width()             // Y axis width
             - 3;                               // grapher and Y axis borders
   }

   function initializeGrapher() {
      var now = new Date();
      var midnight = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      var channelMinTimeSecs = midnight.getTime() / 1000;
      var channelMaxTimeSecs = now.getTime() / 1000;

      // Grapher is not happy if min time equals max time.  Adjust them if necessary
      if (channelMinTimeSecs == channelMaxTimeSecs) {
         channelMinTimeSecs--;
         channelMaxTimeSecs++;
      }

      plotManager = new org.bodytrack.grapher.PlotManager("date_axis", channelMinTimeSecs, channelMaxTimeSecs);
      plotManager.setWillAutoResizeWidth(true, getDesiredPlotManagerSize);

      // create the plot container so that we can turn autoscaling on by default (but don't pad)
      plotManager.addPlotContainer("plot_container").setAutoScaleEnabled(true, false);

      $("#export_this_channel_button").click(function() {
         doExport(false);
         return false;
      });
      $("#export_all_channels_button").click(function() {
         doExport(true);
         return false;
      });

      setSizes();

      // set up window resize handler
      $(window).resize(setSizes);
   }

   function initializeMarkers() {
      // add the govt feeds
      govtFeeds.forEach(function(feed) {
         var latitude = feed['latitude'];
         var longitude = feed['longitude'];
         if (latitude != null && longitude != null) {
            feedsById[feed.id] = feed;
            govtFeedsById[feed.id] = feed;
            var latLng = new google.maps.LatLng(feed['latitude'], feed['longitude']);
            map.addMarker(feed.id, latLng, renderMarker);
         }
      });

      // add the indoor speck feeds
      speckFeeds.indoor.forEach(function(feed) {
         var latitude = feed['latitude'];
         var longitude = feed['longitude'];
         if (latitude != null && longitude != null) {
            feedsById[feed.id] = feed;
            speckFeedsById.indoor[feed.id] = feed;
            var latLng = new google.maps.LatLng(feed['latitude'], feed['longitude']);
            map.addMarker(feed.id, latLng, renderMarker);
         }
      });

      // add the outdoor speck feeds
      speckFeeds.outdoor.forEach(function(feed) {
         var latitude = feed['latitude'];
         var longitude = feed['longitude'];
         if (latitude != null && longitude != null) {
            feedsById[feed.id] = feed;
            speckFeedsById.outdoor[feed.id] = feed;
            var latLng = new google.maps.LatLng(feed['latitude'], feed['longitude']);
            map.addMarker(feed.id, latLng, renderMarker);
         }
      });

      // add handler to redraw markers if the user toggles the feed filter checkboxes
      $(".feed_filter").change(function() {
         // update the map with which markers are active (i.e. visible)
         var markerIds = null;
         switch (this.id) {
            case "indoor_speck_checkbox":
               markerIds = Object.keys(speckFeedsById.indoor);
               break;
            case "outdoor_speck_checkbox":
               markerIds = Object.keys(speckFeedsById.outdoor);
               break;
            default:
               markerIds = Object.keys(govtFeedsById);
         }
         map.setMarkersActiveById(markerIds, this.checked);
         map.renderMarkers();
      });
   }

   var getGovtMarkerColor = function(value) {

      if (typeof value === 'undefined' || value == null) {
         return "rgba(10, 10, 10, 0.6)";
      }

      if (value <= 12) {
         return "rgb(0, 228, 0)";
      }
      else if (value <= 35.4) {
         return "rgb(255, 255, 0)";
      }
      else if (value <= 55.4) {
         return "rgb(255, 126, 0)";
      }
      else if (value <= 150.4) {
         return "rgb(255, 0, 0)";
      }
      else if (value <= 250.4) {
         return "rgb(153, 0, 76)";
      }

      return "rgb(126, 0, 35)";
   };

   function renderMarker(marker, canvasPosition, context, filterStates) {
      var feed = feedsById[marker.id];

      var willDrawMarker = (govtFeedsById[feed.id] && filterStates.willShowGovtFeeds) ||
                           (speckFeedsById.indoor[feed.id] && filterStates.willShowIndoorSpeckFeeds) ||
                           (speckFeedsById.outdoor[feed.id] && filterStates.willShowOutdoorSpeckFeeds) ||
                           (selectedFeed != null && selectedFeed.id == feed.id);    // make sure the selected marker is drawn, even if the filter for it is disabled

      if (willDrawMarker) {
         var isGovtFeed = marker.id in govtFeedsById;

         context.beginPath();
         if (isGovtFeed) {
            // draw a square
            context.rect(canvasPosition.x - MARKER_RADIUS, canvasPosition.y - MARKER_RADIUS, 2 * MARKER_RADIUS, 2 * MARKER_RADIUS);
            context.fillStyle = getGovtMarkerColor(govtRecentValuesByFeedId[marker.id]);
         }
         else {
            // draw a circle
            context.arc(canvasPosition.x, canvasPosition.y, MARKER_RADIUS, 0, TWO_PI, false);
            context.fillStyle = "rgba(10, 10, 10, 0.6)";
         }
         context.fill();
         context.lineWidth = 1;
         context.strokeStyle = "rgb(10, 10, 10)";
         context.stroke();
      }
   }

   function setFeedSelected(feedId) {
      if (feedId == null) {
         // remove the current feed from the grapher (if any)
         removeFeedFromGrapher(selectedFeed);

         $(".daily_stats_calendar_and_table").remove();

         $(".grapher_item").hide();

         selectedFeed = null;

         // update markers
         map.renderMarkers();
      }
      else {
         var feed = feedsById[feedId];

         // shrink the map height to make room for the grapher, and the set the center of the map
         if ($(window).width() > EXTRA_SMALL_DEVICE_WIDTH_PIXELS) {
            map.setHeight(300);
         }

         // if this is the first time a marker is selected, center the marker on the map
         if (selectedFeed == null) {
            map.setCenter(feed.latitude, feed.longitude);
         }

         // display the feed name (important to use .text here instead of .html to prevent XSS)
         $(".feed_name_label").text(feed.name);

         if (selectedFeed == null || selectedFeed.id != feedId) {

            // remove the current feed from the grapher (if any)
            removeFeedFromGrapher(selectedFeed);

            selectedFeed = feed;

            // update the grapher
            addFeedToGrapher(selectedFeed);

            // show the daily stats, if appropriate
            renderDailyStats(feed);

            // update markers
            map.renderMarkers();
         }
      }
   }

   function removeFeedFromGrapher(feed) {
      if (feed) {
         var plotId = feed.id;

         plotManager.getPlotContainer().removePlot(plotId);

         $("#y_axis_label").empty();
         $("#channel_switcher_menu_items").empty();
         $("#value_and_time").empty();
      }
   }

   function isChannelInChannelSpecs(channelSpecs, channelName) {
      if (channelSpecs) {
         // deal with different versions of channelSpecs
         var version = channelSpecs.version || -1;
         switch (version) {
            case 1:
               return ("channels" in channelSpecs && channelName in channelSpecs['channels']);
               break;
            default:
               return channelName in channelSpecs;
         }
      }

      return false;
   }

   function getChannelPropertyFromChannelSpecs(channelSpecs, channelName, propertyName) {
      if (channelSpecs) {
         // deal with different versions of channelSpecs
         var version = channelSpecs.version || 0;
         switch (version) {
            case 1:
               if ("channels" in channelSpecs && channelName in channelSpecs['channels']) {
                  return channelSpecs["channels"][channelName][propertyName];
               }
               break;
            default:
               if (channelName in channelSpecs) {
                  return channelSpecs[channelName][propertyName];
               }
         }
      }

      return undefined;
   }

   function addFeedToGrapher(feed, willPreserveDateAxis) {
      if (feed) {
         willPreserveDateAxis = !!willPreserveDateAxis;

         $(".grapher_item").show();

         // Since different feeds can have different sets of channels, we need to make sure that the selectedChannelName
         // actually exists in the new feed.  If not, try the DEFAULT_CHANNEL_NAMES or, if that fails too, then just use
         // the first channel (alphabetically)
         if (!(selectedChannelName in feed.channelBounds.channels)) {
            var channelNameToUse = null;
            for (var i = 0; i < DEFAULT_CHANNEL_NAMES.length; i++) {
               var channelName = DEFAULT_CHANNEL_NAMES[i];
               if (channelName in feed.channelBounds.channels) {
                  channelNameToUse = channelName;
                  break;
               }
            }
            if (channelNameToUse != null) {
               selectedChannelName = channelNameToUse;
            }
            else {
               selectedChannelName = Object.keys(feed.channelBounds.channels).sort()[0];
            }
         }

         if (!willPreserveDateAxis) {
            // If we're not preserving the time range, then try to show up to 7 days of history.  See inline comments
            // for details about the logic...

            var now = Date.now() / 1000;
            var sevenDaysAgoBeforeMax = now - SEVEN_DAYS_IN_SECS;

            var channelMinTimeSecs = feed.channelBounds.channels[selectedChannelName].minTimeSecs;
            var channelMaxTimeSecs = feed.channelBounds.channels[selectedChannelName].maxTimeSecs;

            // if the feed's most recent data is older than 7 days ago, then make the max time on the date axis equal
            // to the channel's max time.  Otherwise, just set it to now.
            var max = now;
            if (channelMaxTimeSecs < sevenDaysAgoBeforeMax) {
               max = channelMaxTimeSecs;

               // recompute the sevenDaysAgoBeforeMax, since we've changed the max
               sevenDaysAgoBeforeMax = max - SEVEN_DAYS_IN_SECS;
            }

            // set the date range's min to either the channel's min time, or 7 days ago before the max time computed
            // above, whichever is more recent.
            var min = Math.max(channelMinTimeSecs, sevenDaysAgoBeforeMax);

            // Grapher is not happy if min time equals max time.  Adjust them if necessary
            if (min == max) {
               min--;
               max++;
            }

            plotManager.getDateAxis().constrainRangeTo(feed.channelBounds.minTimeSecs, now);
            plotManager.getDateAxis().setRange(min, max);
         }

         // set the Y axis label
         var channelUnits = null;
         var yAxisLabel = null;
         var prettyName = selectedChannelName;
         if (isChannelInChannelSpecs(feed['channelSpecs'], selectedChannelName)) {
            prettyName = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], selectedChannelName, 'prettyName');
            var units = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], selectedChannelName, 'units');
            if (prettyName) {
               yAxisLabel = prettyName;
            }
            if (units) {
               channelUnits = units;
               yAxisLabel += " (" + units + ")";
            }
         }
         else {
            yAxisLabel = selectedChannelName;
         }
         $("#y_axis_label").text(yAxisLabel == null ? "" : yAxisLabel); // important to use .text here instead of .html to prevent XSS

         // set the channel menu button label to the currently-selected channel name (important to use .text here instead of .html to prevent XSS)
         $("#channel_switcher_menu_label").text(prettyName);

         // render the links to change channels
         $("#channel_switcher_menu_items").empty();
         if (feed['channelBounds'] && feed['channelBounds']['channels']) {
            var availableChannels = Object.keys(feed['channelBounds']['channels']).sort();
            if (!(selectedChannelName in feed['channelBounds']['channels'])) {
               selectedChannelName = availableChannels[0];
            }

            var channelNameMenuItemTemplate = Handlebars.templates['grapher_channel_menu_item'];
            availableChannels.forEach(function(channelName) {
               var prettyChannelName = channelName;
               if (isChannelInChannelSpecs(feed['channelSpecs'], channelName)) {
                  prettyChannelName = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], channelName, 'prettyName');
               }
               var selectionStateClass = (channelName == selectedChannelName) ? 'selected' : 'unselected';

               var menuItemElement = $(channelNameMenuItemTemplate({
                                                                      channelName : prettyChannelName,
                                                                      cssClass : selectionStateClass
                                                                   }));

               // add click event handler to the channel change links
               if (channelName != selectedChannelName) {
                  menuItemElement.click(function() {
                     // update the grapher to show the newly selected channel
                     selectedChannelName = channelName;
                     removeFeedFromGrapher(selectedFeed);
                     addFeedToGrapher(selectedFeed, true);
                  });
               }
               $("#channel_switcher_menu_items").append(menuItemElement);
            });
         }

         var plotId = feed.id;
         plotManager.addDataSeriesPlot(plotId,
                                       function(level, offset, successCallback) {
                                          superagent
                                                .get(ESDR_API_ROOT_URL + "/feeds/" + feed.id + "/channels/" + selectedChannelName + "/tiles/" + level + "." + offset)
                                                .end(function(err, res) {
                                                   if (err) {
                                                      console.log(err);
                                                   }
                                                   else {
                                                      // got the data
                                                      if (res.body.code == 200 &&
                                                          typeof res.body.data !== 'undefined' &&
                                                          res.body.data != null) {

                                                         successCallback(res.body.data);
                                                      }
                                                      else {
                                                         console.log(new Error("Failed to get tile [" + level + "." + offset + "] for feed.channel [" + feed.id + "." + selectedChannelName + "]"));
                                                      }
                                                   }
                                                });
                                       },
                                       "plot_container",
                                       "y_axis",
                                       feed.channelBounds.channels[selectedChannelName].minValue,
                                       feed.channelBounds.channels[selectedChannelName].maxValue);

         plotManager.getPlot(plotId).addDataPointListener(function(val) {
            var valueAndTimeElement = $("#value_and_time");
            if (val == null) {
               valueAndTimeElement.empty().hide();
            }
            else {
               // important to use .text here instead of .html to prevent XSS
               valueAndTimeElement.text(val.valueString + (channelUnits == null ? "" : " " + channelUnits) + " at " + val.dateString).show();
            }
         });

         var isParticleConcentrationChannel = (selectedChannelName == "particle_concentration");
         var isParticleCountChannel = (selectedChannelName == "particle_count");
         var yAxis = plotManager.getYAxis();
         if (isParticleConcentrationChannel) {
            yAxis.constrainRangeTo(0, 640, true);
         }
         else if (isParticleCountChannel) {
            yAxis.constrainRangeTo(0, 16000, true);
         }
         else {
            yAxis.constrainRangeTo(-1 * Number.MAX_VALUE, Number.MAX_VALUE);
         }

         setSizes();
      }
   }

   function hasStatsChannels(feed, pm25ChannelName) {
      for (var j = 0; j < DAILY_STATS_CHANNEL_NAME_SUFFIXES.length; j++) {
         var suffix = DAILY_STATS_CHANNEL_NAME_SUFFIXES[j];
         var statsChannelName = pm25ChannelName + suffix;
         if (!(statsChannelName in feed.channelBounds.channels)) {

            console.log("Feed [" + feed.id + "] channel [" + pm25ChannelName + "] does not have stats channel [" + statsChannelName + "]");
            return false;
         }
      }

      return true;
   }

   // determine whether we should even show the daily stats calendar.  We only show it for govt feeds and only if
   // the selected channel is a PM2.5 feed with associated daily stats channels.
   function renderDailyStats(feed) {
      var grapherContainerElement = $("#grapher_container");

      $(".daily_stats_calendar_and_table").remove();
      grapherContainerElement.addClass("col-sm-12").removeClass("col-sm-7 col-sm-pull-5 col-md-8 col-md-pull-4");

      if (feed.id in govtFeedsById) {
         var pm25Channels = [];

         // keep track of the channel which has the earliest starting time, so, for feeds which have multiple PM2.5
         // channels, all the calendars will be the same size
         var minTimeSecs = Number.MAX_VALUE;
         for (var i = 0; i < GOVT_PM_2_5_CHANNEL_NAMES.length; i++) {
            var channelName = GOVT_PM_2_5_CHANNEL_NAMES[i];
            if (channelName in feed.channelBounds.channels && hasStatsChannels(feed, channelName)) {
               minTimeSecs = Math.min(minTimeSecs, feed.channelBounds.channels[channelName].minTimeSecs);
               pm25Channels.push(channelName);
            }
         }

         if (pm25Channels.length > 0) {
            grapherContainerElement.removeClass("col-sm-12").addClass("col-sm-7 col-sm-pull-5 col-md-8 col-md-pull-4");

            var minYear = new Date(minTimeSecs * 1000).getFullYear();

            var createStatsFetcher = function(feedId, pm25ChannelName, pm25StatsChannelName) {
               return function(done) {
                  superagent
                        .get(ESDR_API_ROOT_URL + "/feeds/" + feedId + "/channels/" + pm25StatsChannelName + "/export?format=json")
                        .end(function(err, res) {
                           if (err) {
                              console.log("Failed to get export of channel [" + pm25StatsChannelName + "] for feed [" + feedId + "]");
                           }
                           else {
                              if (res.body && res.body.data) {
                                 var statsByYear = {
                                    all : {
                                       numDays : 0,
                                       level0 : 0,
                                       level1 : 0,
                                       level2 : 0,
                                       level3 : 0,
                                       level4 : 0,
                                       level5 : 0
                                    }
                                 };
                                 statsDataByChannel[pm25ChannelName][pm25StatsChannelName].years = [];
                                 statsDataByChannel[pm25ChannelName][pm25StatsChannelName].statsByYear = statsByYear;
                                 for (var theYear = minYear; theYear <= new Date().getFullYear(); theYear++) {
                                    statsDataByChannel[pm25ChannelName][pm25StatsChannelName].years.push(theYear);
                                    statsByYear[theYear] = {
                                       numDays : 0,
                                       level0 : 0,
                                       level1 : 0,
                                       level2 : 0,
                                       level3 : 0,
                                       level4 : 0,
                                       level5 : 0
                                    };
                                 }

                                 // compute yearly stats
                                 var newData = {};
                                 for (var i = 0; i < res.body.data.length; i++) {
                                    var unixTimeSecs = res.body.data[i][0];
                                    var value = res.body.data[i][1];
                                    var year = new Date(1000 * unixTimeSecs).getFullYear();
                                    statsByYear[year].numDays++;
                                    statsByYear['all'].numDays++;
                                    if (value <= 12) {
                                       statsByYear[year].level0++;
                                       statsByYear['all'].level0++;
                                    }
                                    else if (value <= 35.4) {
                                       statsByYear[year].level1++;
                                       statsByYear['all'].level1++;
                                    }
                                    else if (value <= 55.4) {
                                       statsByYear[year].level2++;
                                       statsByYear['all'].level2++;
                                    }
                                    else if (value <= 150.4) {
                                       statsByYear[year].level3++;
                                       statsByYear['all'].level3++;
                                    }
                                    else if (value <= 250.4) {
                                       statsByYear[year].level4++;
                                       statsByYear['all'].level4++;
                                    }
                                    else {
                                       statsByYear[year].level5++;
                                       statsByYear['all'].level5++;
                                    }

                                    newData[unixTimeSecs] = value;
                                 }

                                 // now compute percentages
                                 var computePercentages = function(group) {
                                    for (var level = 0; level <= 5; level++) {
                                       group['level' + level + 'Perc'] = (group.numDays > 0) ? group['level' + level] / group.numDays : 0;
                                    }
                                 };
                                 statsDataByChannel[pm25ChannelName][pm25StatsChannelName].years.forEach(function(year) {
                                    computePercentages(statsByYear[year]);
                                 });
                                 computePercentages(statsByYear['all']);

                                 // save the data for use by the calendar heatmap library
                                 statsDataByChannel[pm25ChannelName][pm25StatsChannelName].data = newData;
                              }
                           }
                           done();
                        });
               };
            };

            // build the commands to fetch all the stats channel export data
            var commands = [];
            statsDataByChannel = {};
            pm25Channels.forEach(function(pm25ChannelName) {
               statsDataByChannel[pm25ChannelName] = {};
               // TODO: change to DAILY_STATS_CHANNEL_NAME_SUFFIXES once we support toggling max/mean/median
               ["_daily_max"].forEach(function(suffix) {
                  var pm25StatsChannelName = pm25ChannelName + suffix;
                  statsDataByChannel[pm25ChannelName][pm25StatsChannelName] = {};
                  commands.push(createStatsFetcher(feed.id, pm25ChannelName, pm25StatsChannelName));
               });
            });

            // fetch the export data
            var statsContainer = $("#stats_container");
            _.parallel(commands,
                       function() {

                          var startDate = new Date(minTimeSecs * 1000);
                          var hasMultipleChannels = pm25Channels.length > 1;
                          pm25Channels.forEach(function(pm25ChannelName) {
                             var pm25StatsChannelName = pm25ChannelName + "_daily_max";
                             var calendarElementId = "daily_stats_calendar_" + feed.id + "_" + pm25ChannelName;
                             var dailyStatsCalendarAndTableElement = $(dailyStatsCalendarAndTableTemplate({
                                                                                                             calendarElementId : calendarElementId,
                                                                                                             channelName : pm25ChannelName,
                                                                                                             hasMultipleChannels : hasMultipleChannels,
                                                                                                             statsByYear : statsDataByChannel[pm25ChannelName][pm25StatsChannelName].statsByYear,
                                                                                                             years : statsDataByChannel[pm25ChannelName][pm25StatsChannelName].years
                                                                                                          }));
                             statsContainer.append(dailyStatsCalendarAndTableElement);

                             // add event handlers for day counts vs percentages
                             var daysTable = dailyStatsCalendarAndTableElement.find(".days_table");
                             var percTable = dailyStatsCalendarAndTableElement.find(".perc_table");
                             dailyStatsCalendarAndTableElement.find("#percentages_toggle_" + pm25ChannelName).click(function() {
                                daysTable.hide();
                                percTable.show();
                             });
                             dailyStatsCalendarAndTableElement.find("#counts_toggle_" + pm25ChannelName).click(function() {
                                percTable.hide();
                                daysTable.show();
                             });

                             cal = new CalHeatMap();
                             cal.init(createDailyStatsCalendarOptions(calendarElementId, statsDataByChannel[pm25ChannelName][pm25StatsChannelName].data, startDate));
                          });
                       });
         }
      }

      plotManager.setWidth(getDesiredPlotManagerSize());
   }

   function createDailyStatsCalendarOptions(containerElementId, data, startingDate) {
      //var startingDate = new Date(feed.channelBounds.channels[channelName].minTimeSecs * 1000);
      var numYears = new Date().getFullYear() - startingDate.getFullYear() + 1;

      return {
         itemSelector : '#' + containerElementId,
         domain : "year",
         //label : {
         //   position : "left",
         //   width : 20,
         //   rotate : "left",
         //   offset : { x : 15, y : 10 }
         //},
         label : {
            position : "top"
         },
         verticalOrientation : false,
         subDomainTitleFormat : {
            empty : "{date}",
            filled : "{count} {connector} {date}"
         },
         tooltip : false,
         subDomainDateFormat : "%Y-%m-%d",
         subDomain : "x_day",
         start : startingDate,
         data : data,
         onClick : function(date, value) {
            var min = date.getTime() / 1000;    // date is midnight
            var max = min + 86400;              // add number of seconds in 1 day to get the next midnight
            plotManager.getDateAxis().setRange(min, max);
         },
         cellSize : 7,
         cellPadding : 1,
         domainGutter : 10,
         itemName : ["ug/m^3", "ug/m^3"],
         range : numYears,
         legend : [12, 35.4, 55.4, 150.4, 250.4],
         displayLegend : false,
         weekStartOnMonday : false

      }
   }

   function toggleYAxisAutoScaling() {
      var autoScaleToggleButton = $("#auto_scale_toggle_button");
      var isAutoScaleOn = !autoScaleToggleButton.hasClass("active");
      plotManager.getPlotContainer().setAutoScaleEnabled(isAutoScaleOn, false);  // toggle autoscaling, but don't pad
      if (isAutoScaleOn) {
         autoScaleToggleButton.addClass("active");
      }
      else {
         autoScaleToggleButton.removeClass("active");
      }
   }

   function setSizes() {
      // Only show the y axis label if the grapher is tall enough.  If it is, then position it accordingly.
      var yAxisLabelElement = $("#y_axis_label");
      if ($("#plot_container").outerHeight() >= 150) {
         var yAxisElement = $("#y_axis");
         var yAxisWidth = yAxisElement.width();
         var yAxisHeight = yAxisElement.height();
         yAxisLabelElement.width(yAxisHeight); // set the width == height since we're rotating
         var yAxisLabelHeight = yAxisLabelElement.height();

         // compute the position of the y-axis label
         var yAxisLabelLeft = Math.round(yAxisWidth + yAxisLabelHeight / 2 - yAxisHeight / 2 + 2);
         var yAxisLabelTop = Math.round(yAxisHeight / 2 - yAxisLabelHeight / 2);

         // set position and then show it
         yAxisLabelElement
               .css("top", yAxisLabelTop + "px")
               .css("left", yAxisLabelLeft + "px")
               .show();
      }
      else {
         yAxisLabelElement.hide();
      }

      // Change the UI for the channel menu depending on window size.  First, define a function to expand or collapse
      // the channel switcher.  Then we explicitly set it to expanded so that we can get a measurement of its desired
      // size.  Then compute whether it's too big and collapse accordingly.
      var collapseOrExpandChannelSwitcher = function(isCollapsed) {
         $(".horizontal_list_or_menu_button_items")
               .toggleClass("dropdown-menu", isCollapsed)
               .toggleClass("horizontal-list", !isCollapsed);
         if (isCollapsed) {
            $(".menu_button").show();
         }
         else {
            $(".menu_button").hide();
         }
      };

      // force the channel switcher to be expanded so we can measure its desired width next
      collapseOrExpandChannelSwitcher(false);

      // measure the channel switcher's desired width, compute whether it will fit in the available space (with padding)
      // and then collapse or expand accordingly.  Not that if it should be expanded, we don't bother again here, since
      // we just did so above.
      var channelSwitcherMenuItemsWidth = $("#channel_switcher_menu_items").width();
      var autoScaleButtonWidth = $("#auto_scale_toggle_button").width();
      var grapherWidth = $("#grapher").width();
      var willCollapseToMenuButton = (channelSwitcherMenuItemsWidth + 30) > (grapherWidth - autoScaleButtonWidth);
      if (willCollapseToMenuButton) {
         collapseOrExpandChannelSwitcher(willCollapseToMenuButton);
      }
   }

   function doExport(willExportAllChannels) {
      var channels = willExportAllChannels ? Object.keys(selectedFeed.channelBounds.channels).sort().join(',') : selectedChannelName;
      var dateAxisRange = plotManager.getDateAxis().getRange();
      window.open(ESDR_API_ROOT_URL + "/feeds/" + selectedFeed.id + "/channels/" + channels + "/export?from=" + dateAxisRange.min + "&to=" + dateAxisRange.max, '_blank');
   }

   // This is annoying. We need to read the timestamp of the PM2.5 channel for govt feeds so we can determine whether
   // the data is stale and whether it's more recent than other feeds in the geocoded area.  But, since there are a
   // variety of channel names which all mean PM2.5, we need to check the feed for each one until we find the right
   // one.  And THEN, we return that channel's maxTimeSecs field. Dude.
   function getMaxTimeSecsOfGovtFeedPM25Channel(feed) {
      if (feed && feed.channelBounds && feed.channelBounds.channels) {
         // TODO: fix this for feeds such as #26 which have multiple PM2.5 channels
         for (var i = 0; i < GOVT_PM_2_5_CHANNEL_NAMES.length; i++) {
            var channelName = GOVT_PM_2_5_CHANNEL_NAMES[i];
            if (channelName in feed.channelBounds.channels) {
               return feed.channelBounds.channels[channelName].maxTimeSecs;
            }
         }
      }
      return null;
   }

   function findGovtFeedsWithinBoundingBox(boundingBox) {
      var center = boundingBox.getCenter();
      var currentTimeSecs = Date.now() / 1000;
      var fourHoursAgo = currentTimeSecs - FOUR_HOURS_IN_SECONDS;

      var obj = {
         feeds : null,
         nearest : {
            feed : null,
            distanceKm : Number.MAX_VALUE,
            maxTimeSecs : -Number.MAX_VALUE
         },
         mostRecent : {
            feed : null,
            distanceKm : Number.MAX_VALUE,
            maxTimeSecs : -Number.MAX_VALUE
         }
      };

      var distanceByFeedId = {};
      var maxTimeSecsByFeedId = {};
      obj.feeds = govtFeeds.filter(function(feed) {
         var isContained = boundingBox.contains(feed.latLng);

         // if this feed is within the bounding box, see whether it's either the closest feed, or the one with the
         // most recent data
         if (isContained) {

            // only consider this feed if the data isn't stale (i.e. more than 4 hours old)
            var maxTimeSecs = getMaxTimeSecsOfGovtFeedPM25Channel(feed);
            if (maxTimeSecs > fourHoursAgo) {
               // compute the distance, but divide by 1000 to get kilometers
               var distanceKm = google.maps.geometry.spherical.computeDistanceBetween(center, feed.latLng) / 1000;

               // ignore this feed if it's not within the search radius (we want a circular radius, but the bounding
               // box containment check is rectangular)
               if (distanceKm < SEARCH_RADIUS_IN_KM) {
                  // check whether this is the new closest feed
                  if (distanceKm < obj.nearest.distanceKm) {
                     obj.nearest.feed = feed;
                     obj.nearest.distanceKm = distanceKm;
                     obj.nearest.maxTimeSecs = maxTimeSecs;
                  }

                  distanceByFeedId[feed.id] = distanceKm;
                  maxTimeSecsByFeedId[feed.id] = maxTimeSecs;

                  return true;
               }
            }
         }
         return false;
      });

      if (obj.feeds.length > 0) {
         // now that we have a subset of contained feeds with data that isn't stale, run through that subset and
         // see if any of them has data newer than the closest feed.
         obj.mostRecent.feed = obj.nearest.feed;
         obj.mostRecent.distanceKm = distanceByFeedId[obj.nearest.feed.id];
         obj.mostRecent.maxTimeSecs = maxTimeSecsByFeedId[obj.nearest.feed.id];
         obj.feeds.forEach(function(feed) {
            if (feed.id != obj.nearest.feed.id) {
               var maxTimeSecs = maxTimeSecsByFeedId[feed.id];
               // check whether this is the new most-recent feed
               if (maxTimeSecs > obj.mostRecent.maxTimeSecs) {
                  obj.mostRecent.feed = feed;
                  obj.mostRecent.distanceKm = distanceByFeedId[feed.id];
                  obj.mostRecent.maxTimeSecs = maxTimeSecs;
               }
            }
         });
      }

      return obj;
   }

   function getMostRecentDataSample(feed, callback) {
      var channelName = "PM2_5";

      // find the PM2.5 channel name for this feed
      for (var i = 0; i < GOVT_PM_2_5_CHANNEL_NAMES.length; i++) {
         var name = GOVT_PM_2_5_CHANNEL_NAMES[i];
         if (name in feed.channelBounds.channels) {
            channelName = name;
            break;
         }
      }

      superagent
            .get(ESDR_API_ROOT_URL + "/feeds/" + feed.id + "/channels/" + channelName + "/most-recent")
            .end(function(err, res) {
               if (err) {
                  callback(err);
               }
               else {
                  // got the data
                  if (res.body.code == 200 &&
                      typeof res.body.data !== 'undefined' &&
                      res.body.data != null &&
                      res.body.data['channels'] &&
                      res.body.data['channels'] &&
                      res.body.data['channels'][channelName] &&
                      res.body.data['channels'][channelName]['mostRecentDataSample']
                  ) {
                     var dataSample = res.body.data['channels'][channelName]['mostRecentDataSample'];
                     dataSample.timeStr = new Date(dataSample.timeSecs * 1000).toTimeString();
                     callback(null, dataSample);
                  }
                  else {
                     callback(new Error("Failed to get most recent value for feed.channel [" + feed.id + "." + channelName + "]"));
                  }
               }
            });
   }

   function displayGeocodeResults(address, latLng, results) {
      var template = null;
      var templateOptions = null;
      if (results) {
         if (results.feeds.length > 0) {
            if (results.nearest.feed.id == results.mostRecent.feed.id) {
               return getMostRecentDataSample(results.nearest.feed, function(err, dataSample) {
                  template = Handlebars.templates['public_data_geocode_found_one'];
                  templateOptions = {
                     dataSample : dataSample,
                     nearest : results.nearest.feed
                  };
                  $("#results").empty().append($(template(templateOptions)));
               });
            }
            else {

               var nearestDataSample = null;
               var mostRecentDataSample = null;
               return _.parallel(
                     [
                        function(done) {
                           getMostRecentDataSample(results.nearest.feed, function(err, dataSample) {
                              nearestDataSample = dataSample;
                              done();
                           });
                        },
                        function(done) {
                           getMostRecentDataSample(results.mostRecent.feed, function(err, dataSample) {
                              mostRecentDataSample = dataSample;
                              done();
                           });
                        }
                     ],
                     function() {
                        var distanceDiff = results.mostRecent.distanceKm - results.nearest.distanceKm;
                        var distanceDiffKm = distanceDiff.toFixed(2);
                        var distanceDiffMi = (distanceDiff * 0.621371).toFixed(2);
                        var timeDiff = ((results.mostRecent.maxTimeSecs - results.nearest.maxTimeSecs) / 3600).toFixed(1);
                        timeDiff = (Math.round(timeDiff) == timeDiff) ? Math.round(timeDiff) : timeDiff;

                        template = Handlebars.templates['public_data_geocode_found_two'];
                        templateOptions = {
                           nearest : results.nearest.feed,
                           nearestDataSample : nearestDataSample,
                           mostRecent : results.mostRecent.feed,
                           mostRecentDataSample : mostRecentDataSample,
                           distanceDiffKm : distanceDiffKm,
                           distanceDiffMi : distanceDiffMi,
                           timeDiff : timeDiff,
                           hourPlurality : (timeDiff <= 1 ? '' : 's')
                        };
                        $("#results").empty().append($(template(templateOptions)));

                     }
               );
            }
         }
         else {
            template = Handlebars.templates['public_data_no_nearby_stations'];
         }
      }
      else {
         template = Handlebars.templates['public_data_geocode_failed'];
         map.setCenter(MAP_CENTER);
         map.setZoomLevel(getDefaultMapZoomLevel());
         setGeolocationMarkerLocation(null);
      }

      $("#results").empty().append($(template(templateOptions)));
   }

   function setGeolocationMarkerLocation(latLng) {
      // move the marker (if any) to the newly geocoded location
      if (geocodedLocationMarker != null) {
         geocodedLocationMarker.setMap(null);
      }
      if (latLng instanceof google.maps.LatLng) {
         geocodedLocationMarker = new google.maps.Marker({
            position : latLng,
            map : map.getWrappedMap()
         });
      }
   }

   function geocodeAddress(address) {
      map.geocodeAddress(address, function(err, latLng, results) {
         if (err) {
            console.log(err);
            setFeedSelected(null);
            displayGeocodeResults(address, null, null);
         }
         else {
            console.log("Geocoded [" + address + "] --> " + latLng.toString());
            map.setCenter(latLng);
            map.setZoomLevel(12);

            // move the marker to the newly geocoded location
            setGeolocationMarkerLocation(latLng);
            var boundingBox = map.getBoundingBoxAroundLocation(latLng, SEARCH_RADIUS_IN_KM);
            var foundFeeds = findGovtFeedsWithinBoundingBox(boundingBox);

            // if we found a feed in the search area, then fit the geocoded location, the nearest found feed, and the
            // feed with the most-recent data on the map
            if (foundFeeds.feeds.length > 0) {
               setFeedSelected(foundFeeds.nearest.feed.id);
               map.fitMapBoundsToLocations([latLng, foundFeeds.nearest.feed.latLng, foundFeeds.mostRecent.feed.latLng]);
            }
            else {
               setFeedSelected(null);
               map.fitBounds(boundingBox);
            }

            displayGeocodeResults(address, latLng, foundFeeds);
         }
      });
   }

</script>
<div id="public_data_page">
   <h2>Public Data</h2>
   <div class="row">
      <div id="instructions" class="col-xs-12">
         <p>
            This map shows the locations of regulated PM<sub>2.5</sub> stations and all public Specks. Enter an address
            or location to find the nearest regulated station and see the current and historical air quality. Or, select
            a marker on the map to see a plot of the air quality at that location. The regulated station
            markers are colored according to their most recent value using the US EPA PM<sub>2.5</sub> scale shown below.
         </p>
         <div class="geocode_form_container">
            <form class="geocode_form" action="/public-data" method="get" style="display:none"></form>
            <div class="input-group">
               <input type="text" class="form-control geocode_location" placeholder="Search for an address or location"/>
               <span class="input-group-btn">
                 <button class="btn btn-default geocode_submit_button" type="button"><i class="fa fa-search"></i>
                 </button>
               </span>
            </div>
         </div>
      </div>
      <div id="results" class="col-xs-12"></div>
   </div>
   <div class="row">
      <div id="map_container" class="noselect col-sm-7 col-md-8">
         <div id="map_area"></div>
         <div id="map_filters_area">
            <div class="map_filter">
               <input type="checkbox" id="govt_feed_checkbox" class="feed_filter" name="govt_feed_checkbox" checked="checked"/>
               <label for="govt_feed_checkbox">Regulated PM<sub>2.5</sub> Stations</label>
            </div>
            <div class="map_filter">
               <input type="checkbox" id="outdoor_speck_checkbox" class="feed_filter" name="outdoor_speck_checkbox" checked="checked"/>
               <label for="outdoor_speck_checkbox">Outdoor Specks</label>
            </div>
            <div class="map_filter">
               <input type="checkbox" id="indoor_speck_checkbox" class="feed_filter" name="indoor_speck_checkbox" checked="checked"/>
               <label for="indoor_speck_checkbox">Indoor Specks</label>
            </div>
         </div>
      </div>
      <div class="col-sm-5 col-md-4">
         {{> pm_2_5_scale_table}}
      </div>
   </div>
   <div class="row">
      <div id="selected_feed_name_label" class=" col-sm-12">
         <div class="feed_name_label grapher_item"></div>
      </div>
      <div id="stats_container" class="noselect col-sm-5 col-sm-push-7 col-md-4 col-md-push-8"></div>
      <div id="grapher_container" class="noselect col-sm-7 col-sm-pull-5 col-md-8 col-md-pull-4">
         <table id="grapher" class="grapher_item" border="0" cellpadding="0" cellspacing="0" style="display:none">
            <tr>
               <td>
                  <div id="date_axis" class="date_axis"></div>
               </td>
               <td align="center" valign="bottom">
                  <div id="export_button_container" class="btn-group">
                     <button id="export_button" type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-expanded="false" title="Download the data">
                        <i class="fa fa-cloud-download"></i>
                     </button>
                     <ul id="export_button_menu" class="dropdown-menu dropdown-menu-right" role="menu">
                        <li><a id="export_this_channel_button" href="#">This Channel</a></li>
                        <li><a id="export_all_channels_button" href="#">All Channels</a></li>
                     </ul>
                  </div>
               </td>
            </tr>
            <tr>
               <td>
                  <div id="plot_container" class="plot_container" style="height:300px; border: 1px solid black;">
                     <div id="value_and_time"></div>
                  </div>
               </td>
               <td>
                  <div id="y_axis" class="y_axis" style="height:300px">
                     <div id="y_axis_label" class="rotate_90 y_axis_label">&nbsp;</div>
                  </div>
               </td>
            </tr>
            <tr>
               <td colspan="2" align="right">
                  <div id="grapher_toolbar_bottom" class="grapher_toolbar">
                     <div class="pull-left">
                        <div id="channel_switcher_menu" class="horizontal_list_or_menu_button btn-group dropup">
                           <button type="button" class="menu_button btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown" aria-expanded="false">
                              <span id="channel_switcher_menu_label"></span> <span class="caret"></span>
                           </button>
                           <ul id="channel_switcher_menu_items" class="horizontal_list_or_menu_button_items dropdown-menu" role="menu"></ul>
                        </div>
                     </div>

                     <div class="btn-group pull-right">
                        <a id="auto_scale_toggle_button" class="btn btn-default btn-sm active" href="#" onclick="toggleYAxisAutoScaling(); return false;" title="Toggle Y axis auto-scaling">Auto Scale</a>
                     </div>
                  </div>
               </td>
            </tr>
         </table>
      </div>
   </div>
</div>
