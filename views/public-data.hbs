<link href="/css/grapher.css" rel="stylesheet" type="text/css"/>
<script src="https://maps.googleapis.com/maps/api/js?key={{{googleMapsApiKey}}}&libraries=geometry" type="text/javascript"></script>
<script src="/lib/canvas-layer/src/CanvasLayer.js" type="text/javascript"></script>
<script src="/js/com/specksensor/geo/Map.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/jquery-mousewheel/jquery.mousewheel.min.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/createlab-grapher/grapher.min.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/plot-manager/org/bodytrack/grapher/PlotManager.js" type="text/javascript"></script>
<script src="/lib/nimble/nimble.min.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
   // hardcode these to production since dev/test/stage don't have enough data to be interesting
   var ESDR_API_ROOT_URL = 'https://esdr.cmucreatelab.org/api/v1';
   var PRODUCT_ID = 9;

   var ESDR_QUERY_ITEM_LIMIT = 1000;

   var DEFAULT_CHANNEL_NAMES = [
      "particle_count",
      "particle_concentration",
      "PM2_5",
      "PM25B_UG_M3",
      "PM25_2__UG_M3",
      "PM25_UG_M3"
   ];

   var GOVT_PM_2_5_CHANNEL_NAMES = [
      "PM2_5",
      "PM25B_UG_M3",
      "PM25_2__UG_M3",
      "PM25_UG_M3"
   ];

   var SEVEN_DAYS_IN_SECS = 604800;

   var EXTRA_SMALL_DEVICE_WIDTH_PIXELS = 629;

   // map and marker rendering
   var MAP_CENTER = new google.maps.LatLng(26.59657854674542, 7.913147269592282);
   var SELECTED_MARKER_COLOR = "#ff0000";
   var MARKER_RADIUS = 5;
   var TWO_PI = 2 * Math.PI;

   // look within a bounding box with radius of 50 km around geocoded location
   var SEARCH_RADIUS_IN_KM = 50;
   // when geocoding, ignore govt feeds which have a PM2.5 feed which hasn't been updated within the past 6 hours
   var SIX_HOURS_IN_SECONDS = 6 * 60 * 60;

   // grapher stuff
   var plotManager;
   var currentDateAxisRange = { min : null, max : null };

   // map stuff
   var map = new com.specksensor.geo.Map("map_area");
   var geocodedLocationMarker = null;

   var govtFeeds = [];
   var govtFeedsById = {};
   var speckFeeds = { indoor : [], outdoor : [] };
   var speckFeedsById = { indoor : {}, outdoor : {} };
   var feedsById = {};
   var selectedFeed = null;
   var selectedChannelName = DEFAULT_CHANNEL_NAMES[0];

   function getHashParam(paramName) {
      var hash = window.location.hash.substr(1);
      if (hash == '') {
         return null;
      }

      var hashParts = hash.split('&');
      for (var i = 0; i < hashParts.length; ++i) {
         var keyAndVal = hashParts[i].split('=');
         if (keyAndVal.length != 2) {
            continue;
         }
         if (keyAndVal[0] == paramName) {
            return decodeURIComponent(keyAndVal[1].replace(/\+/g, " "));
         }
      }
      return "";
   }

   function getDefaultMapZoomLevel() {
      return $(window).width() < 600 ? 1 : 2;   // zoom out more for small screens
   }

   // make the height a little smaller when on a screen with a smallish width
   function adjustMapHeightForSmallScreens() {
      //if ($(window).width() < 600) {
      //   map.setHeight(400);
      //}
   }

   window.grapherLoad = function() {
      window.onhashchange = handleGeocode;

      map.initialize(
            {
               center : MAP_CENTER,
               zoom : getDefaultMapZoomLevel(),
               styles : [
                  {
                     featureType : "poi",
                     elementType : "labels",
                     stylers : [
                        { visibility : "off" }
                     ]
                  }
               ]
            },
            {
               searchDistanceFromMarkerInPixels : MARKER_RADIUS
            },
            {
               handleInitializationComplete : function() {
                  _.parallel(
                        [
                           function(done) {
                              loadGovtFeeds(0, done);
                           },
                           function(done) {
                              loadSpeckFeeds(0, done);
                           }
                        ],
                        function(err) {
                           if (err) {
                              // TODO
                              console.log("Failed to load feeds: " + err);
                           }
                           else {
                              // shrink map height when on a screen with a smallish width
                              adjustMapHeightForSmallScreens();

                              console.log("Done loading feeds: [" + govtFeeds.length + "] government, [" + (speckFeeds.indoor.length + speckFeeds.outdoor.length) + "] speck");

                              initializeGrapher();
                              initializeMarkers();
                              map.renderMarkers();

                              handleGeocode();
                           }
                        });
               },
               handleMarkerSelected : function(marker, nearbyMarkers) {
                  // TODO show a popup with all matching markers
                  setFeedSelected(marker.id);
               },
               onBeforeRenderMarkers : function(context) {
                  // calculate and remember feed filter states before rendering, since rendering of each marker needs
                  // to check these states to see whether to draw the marker
                  return {
                     willShowGovtFeeds : $("#govt_feed_checkbox")[0].checked,
                     willShowIndoorSpeckFeeds : $("#indoor_speck_checkbox")[0].checked,
                     willShowOutdoorSpeckFeeds : $("#outdoor_speck_checkbox")[0].checked
                  };
               },
               onAfterRenderMarkers : function(context) {
                  // render the highlight around the selected marker (if any).  We do this last, in onAfterRenderMarkers,
                  // to ensure the highlight appears on top of all the markers
                  if (selectedFeed) {
                     var selectedMarker = map.getMarkerById(selectedFeed.id);
                     var markerCanvasPosition = map.worldPointToCanvasPixelCoords(selectedMarker.worldPoint);
                     context.beginPath();
                     context.arc(markerCanvasPosition.x, markerCanvasPosition.y, MARKER_RADIUS + 1, 0, TWO_PI, false);
                     context.lineWidth = 2;
                     context.strokeStyle = SELECTED_MARKER_COLOR;
                     context.stroke();
                  }
               }
            }
      );
   };

   function handleGeocode() {
      var location = getHashParam('loc');
      if (typeof location !== 'undefined' && location != null && location.length > 0) {
         $(".geocode_location").val(location);
         geocodeAddress(location);
      }
   }

   function loadSpeckFeeds(page, done) {
      var offset = ESDR_QUERY_ITEM_LIMIT * page;

      // load the Speck feeds (public feeds, having data, and with lat/long defined)
      superagent
            .get(ESDR_API_ROOT_URL + "/feeds?where=productId=" + PRODUCT_ID + ",maxTimeSecs<>__NULL__,latitude<>__NULL__,longitude<>__NULL__&fields=id,name,latitude,longitude,minTimeSecs,maxTimeSecs,channelBounds,channelSpecs,exposure&orderBy=id&limit=" + ESDR_QUERY_ITEM_LIMIT + "&offset=" + offset)
            .end(function(err, res) {
               if (err) {
                  done(err);
               }
               else {
                  // got the data
                  if (res.body.code == 200                 &&
                      typeof res.body.data !== 'undefined' &&
                      res.body.data != null) {

                     // concatenate the new rows, separating indoor and outdoor
                     Array.prototype.push.apply(speckFeeds.indoor, res.body.data.rows.filter(function(feed) {
                        return feed.exposure == 'indoor';
                     }));
                     Array.prototype.push.apply(speckFeeds.outdoor, res.body.data.rows.filter(function(feed) {
                        return feed.exposure == 'outdoor';
                     }));

                     // see whether we need to load more
                     if ((speckFeeds.indoor.length + speckFeeds.outdoor.length) < res.body.data.totalCount) {
                        loadSpeckFeeds(++page, done);
                     }
                     else {
                        done();
                     }
                  }
                  else {
                     done(new Error("Failed to load speck feeds: " + JSON.stringify(res.body, null, 3)));
                  }
               }
            });
   }

   function loadGovtFeeds(page, done) {
      var offset = ESDR_QUERY_ITEM_LIMIT * page;

      superagent
            .get(ESDR_API_ROOT_URL + "/multifeeds/pm_25/feeds?fields=id,name,latitude,longitude,minTimeSecs,maxTimeSecs,channelBounds,channelSpecs&orderBy=id&limit=" + ESDR_QUERY_ITEM_LIMIT + "&offset=" + offset)
            .end(function(err, res) {
               if (err) {
                  done(err);
               }
               else {
                  // got the data
                  if (res.body.code == 200 &&
                      typeof res.body.data !== 'undefined' &&
                      res.body.data != null) {

                     // create a google.maps.LatLng for each feed, for easy bounds containment checking later
                     res.body.data.rows.forEach(function(feed) {
                        feed.latLng = new google.maps.LatLng(feed.latitude, feed.longitude);
                     });

                     // concatenate the new rows
                     Array.prototype.push.apply(govtFeeds, res.body.data.rows);

                     // see whether we need to load more
                     if (govtFeeds.length < res.body.data.totalCount) {
                        loadGovtFeeds(++page, done);
                     }
                     else {
                        done();
                     }
                  }
                  else {
                     done(new Error("Failed to load govt feeds: " + JSON.stringify(res.body, null, 3)));
                  }
               }
            });
   }

   function initializeGrapher() {
      var now = new Date();
      var midnight = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      var channelMinTimeSecs = midnight.getTime() / 1000;
      var channelMaxTimeSecs = now.getTime() / 1000;

      // Grapher is not happy if min time equals max time.  Adjust them if necessary
      if (channelMinTimeSecs == channelMaxTimeSecs) {
         channelMinTimeSecs--;
         channelMaxTimeSecs++;
      }

      plotManager = new org.bodytrack.grapher.PlotManager("date_axis", channelMinTimeSecs, channelMaxTimeSecs);
      plotManager.setWillAutoResizeWidth(true, function() {
         return $("#grapher_container").width()    // window width
                - $(".y_axis").width()             // Y axis width
                - 3;                               // grapher and Y axis borders
      });

      // create the plot container so that we can turn autoscaling on by default (but don't pad)
      plotManager.addPlotContainer("plot_container").setAutoScaleEnabled(true, false);

      $("#export_this_channel_button").click(function() {
         doExport(false);
         return false;
      });
      $("#export_all_channels_button").click(function() {
         doExport(true);
         return false;
      });

      setSizes();

      // set up window resize handler
      $(window).resize(setSizes);
   }

   function initializeMarkers() {
      // add the govt feeds
      govtFeeds.forEach(function(feed) {
         var latitude = feed['latitude'];
         var longitude = feed['longitude'];
         if (latitude != null && longitude != null) {
            feedsById[feed.id] = feed;
            govtFeedsById[feed.id] = feed;
            var latLng = new google.maps.LatLng(feed['latitude'], feed['longitude']);
            map.addMarker(feed.id, latLng, renderMarker);
         }
      });

      // add the indoor speck feeds
      speckFeeds.indoor.forEach(function(feed) {
         var latitude = feed['latitude'];
         var longitude = feed['longitude'];
         if (latitude != null && longitude != null) {
            feedsById[feed.id] = feed;
            speckFeedsById.indoor[feed.id] = feed;
            var latLng = new google.maps.LatLng(feed['latitude'], feed['longitude']);
            map.addMarker(feed.id, latLng, renderMarker);
         }
      });

      // add the outdoor speck feeds
      speckFeeds.outdoor.forEach(function(feed) {
         var latitude = feed['latitude'];
         var longitude = feed['longitude'];
         if (latitude != null && longitude != null) {
            feedsById[feed.id] = feed;
            speckFeedsById.outdoor[feed.id] = feed;
            var latLng = new google.maps.LatLng(feed['latitude'], feed['longitude']);
            map.addMarker(feed.id, latLng, renderMarker);
         }
      });

      // add handler to redraw markers if the user toggles the feed filter checkboxes
      $(".feed_filter").change(function() {
         // update the map with which markers are active (i.e. visible)
         var markerIds = null;
         switch (this.id) {
            case "indoor_speck_checkbox":
               markerIds = Object.keys(speckFeedsById.indoor);
               break;
            case "outdoor_speck_checkbox":
               markerIds = Object.keys(speckFeedsById.outdoor);
               break;
            default:
               markerIds = Object.keys(govtFeedsById);
         }
         map.setMarkersActiveById(markerIds, this.checked);
         map.renderMarkers();
      });
   }

   function renderMarker(marker, canvasPosition, context, filterStates) {
      var feed = feedsById[marker.id];

      var willDrawMarker = (govtFeedsById[feed.id] && filterStates.willShowGovtFeeds) ||
                           (speckFeedsById.indoor[feed.id] && filterStates.willShowIndoorSpeckFeeds) ||
                           (speckFeedsById.outdoor[feed.id] && filterStates.willShowOutdoorSpeckFeeds) ||
                           (selectedFeed != null && selectedFeed.id == feed.id);    // make sure the selected marker is drawn, even if the filter for it is disabled

      if (willDrawMarker) {
         var radius = MARKER_RADIUS;

         // draw a circle
         context.beginPath();
         context.arc(canvasPosition.x, canvasPosition.y, radius, 0, TWO_PI, false);
         context.fillStyle = "rgba(10, 10, 10, 0.6)";
         context.fill();
      }
   }

   function setFeedSelected(feedId) {
      if (feedId == null) {
         // remove the current feed from the grapher (if any)
         removeFeedFromGrapher(selectedFeed);

         $(".grapher_item").hide();

         selectedFeed = null;

         // update markers
         map.renderMarkers();
      }
      else {
         var feed = feedsById[feedId];

         // shrink the map height to make room for the grapher, and the set the center of the map
         if ($(window).width() > EXTRA_SMALL_DEVICE_WIDTH_PIXELS) {
            map.setHeight(300);
         }

         // if this is the first time a marker is selected, center the marker on the map
         if (selectedFeed == null) {
            map.setCenter(feed.latitude, feed.longitude);
         }

         // display the feed name (important to use .text here instead of .html to prevent XSS)
         $(".feed_name_label").text(feed.name);

         if (selectedFeed == null || selectedFeed.id != feedId) {

            // remove the current feed from the grapher (if any)
            removeFeedFromGrapher(selectedFeed);

            selectedFeed = feed;

            // update the grapher
            addFeedToGrapher(selectedFeed);

            // update markers
            map.renderMarkers();
         }
      }
   }

   function removeFeedFromGrapher(feed) {
      if (feed) {
         var plotId = feed.id;

         plotManager.getPlotContainer().removePlot(plotId);

         $("#y_axis_label").empty();
         $("#channel_switcher_menu_items").empty();
         $("#value_and_time").empty();
      }
   }

   function isChannelInChannelSpecs(channelSpecs, channelName) {
      if (channelSpecs) {
         // deal with different versions of channelSpecs
         var version = channelSpecs.version || -1;
         switch (version) {
            case 1:
               return ("channels" in channelSpecs && channelName in channelSpecs['channels']);
               break;
            default:
               return channelName in channelSpecs;
         }
      }

      return false;
   }

   function getChannelPropertyFromChannelSpecs(channelSpecs, channelName, propertyName) {
      if (channelSpecs) {
         // deal with different versions of channelSpecs
         var version = channelSpecs.version || 0;
         switch (version) {
            case 1:
               if ("channels" in channelSpecs && channelName in channelSpecs['channels']) {
                  return channelSpecs["channels"][channelName][propertyName];
               }
               break;
            default:
               if (channelName in channelSpecs) {
                  return channelSpecs[channelName][propertyName];
               }
         }
      }

      return undefined;
   }

   function addFeedToGrapher(feed, willPreserveDateAxis) {
      if (feed) {
         willPreserveDateAxis = !!willPreserveDateAxis;

         $(".grapher_item").show();

         // Since different feeds can have different sets of channels, we need to make sure that the selectedChannelName
         // actually exists in the new feed.  If not, try the DEFAULT_CHANNEL_NAMES or, if that fails too, then just use
         // the first channel (alphabetically)
         if (!(selectedChannelName in feed.channelBounds.channels)) {
            var channelNameToUse = null;
            for (var i = 0; i < DEFAULT_CHANNEL_NAMES.length; i++) {
               var channelName = DEFAULT_CHANNEL_NAMES[i];
               if (channelName in feed.channelBounds.channels) {
                  channelNameToUse = channelName;
                  break;
               }
            }
            if (channelNameToUse != null) {
               selectedChannelName = channelNameToUse;
            }
            else {
               selectedChannelName = Object.keys(feed.channelBounds.channels).sort()[0];
            }
         }

         if (!willPreserveDateAxis) {
            // If we're not preserving the time range, then try to show up to 7 days of history.  See inline comments
            // for details about the logic...

            var now = Date.now() / 1000;
            var sevenDaysAgoBeforeMax = now - SEVEN_DAYS_IN_SECS;

            var channelMinTimeSecs = feed.channelBounds.channels[selectedChannelName].minTimeSecs;
            var channelMaxTimeSecs = feed.channelBounds.channels[selectedChannelName].maxTimeSecs;

            // if the feed's most recent data is older than 7 days ago, then make the max time on the date axis equal
            // to the channel's max time.  Otherwise, just set it to now.
            var max = now;
            if (channelMaxTimeSecs < sevenDaysAgoBeforeMax) {
               max = channelMaxTimeSecs;

               // recompute the sevenDaysAgoBeforeMax, since we've changed the max
               sevenDaysAgoBeforeMax = max - SEVEN_DAYS_IN_SECS;
            }

            // set the date range's min to either the channel's min time, or 7 days ago before the max time computed
            // above, whichever is more recent.
            var min = Math.max(channelMinTimeSecs, sevenDaysAgoBeforeMax);

            // Grapher is not happy if min time equals max time.  Adjust them if necessary
            if (min == max) {
               min--;
               max++;
            }

            plotManager.getDateAxis().constrainRangeTo(channelMinTimeSecs, now);
            plotManager.getDateAxis().setRange(min, max);
         }

         // set the Y axis label
         var channelUnits = null;
         var yAxisLabel = null;
         var prettyName = selectedChannelName;
         if (isChannelInChannelSpecs(feed['channelSpecs'], selectedChannelName)) {
            prettyName = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], selectedChannelName, 'prettyName');
            var units = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], selectedChannelName, 'units');
            if (prettyName) {
               yAxisLabel = prettyName;
            }
            if (units) {
               channelUnits = units;
               yAxisLabel += " (" + units + ")";
            }
         }
         else {
            yAxisLabel = selectedChannelName;
         }
         $("#y_axis_label").text(yAxisLabel == null ? "" : yAxisLabel); // important to use .text here instead of .html to prevent XSS

         // set the channel menu button label to the currently-selected channel name (important to use .text here instead of .html to prevent XSS)
         $("#channel_switcher_menu_label").text(prettyName);

         // render the links to change channels
         $("#channel_switcher_menu_items").empty();
         if (feed['channelBounds'] && feed['channelBounds']['channels']) {
            var availableChannels = Object.keys(feed['channelBounds']['channels']).sort();
            if (!(selectedChannelName in feed['channelBounds']['channels'])) {
               selectedChannelName = availableChannels[0];
            }

            var channelNameMenuItemTemplate = Handlebars.templates['grapher_channel_menu_item'];
            availableChannels.forEach(function(channelName) {
               var prettyChannelName = channelName;
               if (isChannelInChannelSpecs(feed['channelSpecs'], channelName)) {
                  prettyChannelName = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], channelName, 'prettyName');
               }
               var selectionStateClass = (channelName == selectedChannelName) ? 'selected' : 'unselected';

               var menuItemElement = $(channelNameMenuItemTemplate({
                                                                      channelName : prettyChannelName,
                                                                      cssClass : selectionStateClass
                                                                   }));

               // add click event handler to the channel change links
               if (channelName != selectedChannelName) {
                  menuItemElement.click(function() {
                     // update the grapher to show the newly selected channel
                     selectedChannelName = channelName;
                     removeFeedFromGrapher(selectedFeed);
                     addFeedToGrapher(selectedFeed, true);
                  });
               }
               $("#channel_switcher_menu_items").append(menuItemElement);
            });
         }

         var plotId = feed.id;
         plotManager.addDataSeriesPlot(plotId,
                                       function(level, offset, successCallback) {
                                          superagent
                                                .get(ESDR_API_ROOT_URL + "/feeds/" + feed.id + "/channels/" + selectedChannelName + "/tiles/" + level + "." + offset)
                                                .end(function(err, res) {
                                                   if (err) {
                                                      console.log(err);
                                                   }
                                                   else {
                                                      // got the data
                                                      if (res.body.code == 200 &&
                                                          typeof res.body.data !== 'undefined' &&
                                                          res.body.data != null) {

                                                         successCallback(res.body.data);
                                                      }
                                                      else {
                                                         console.log(new Error("Failed to get tile [" + level + "." + offset + "] for feed.channel [" + feed.id + "." + selectedChannelName + "]"));
                                                      }
                                                   }
                                                });
                                       },
                                       "plot_container",
                                       "y_axis",
                                       feed.channelBounds.channels[selectedChannelName].minValue,
                                       feed.channelBounds.channels[selectedChannelName].maxValue);

         plotManager.getPlot(plotId).addDataPointListener(function(val) {
            var valueAndTimeElement = $("#value_and_time");
            if (val == null) {
               valueAndTimeElement.empty().hide();
            }
            else {
               // important to use .text here instead of .html to prevent XSS
               valueAndTimeElement.text(val.valueString + (channelUnits == null ? "" : " " + channelUnits) + " at " + val.dateString).show();
            }
         });

         var isParticleConcentrationChannel = (selectedChannelName == "particle_concentration");
         var isParticleCountChannel = (selectedChannelName == "particle_count");
         var yAxis = plotManager.getYAxis();
         if (isParticleConcentrationChannel) {
            yAxis.constrainRangeTo(0, 640, true);
         }
         else if (isParticleCountChannel) {
            yAxis.constrainRangeTo(0, 16000, true);
         }
         else {
            yAxis.constrainRangeTo(-1 * Number.MAX_VALUE, Number.MAX_VALUE);
         }

         setSizes();
      }
   }

   function toggleYAxisAutoScaling() {
      var autoScaleToggleButton = $("#auto_scale_toggle_button");
      var isAutoScaleOn = !autoScaleToggleButton.hasClass("active");
      plotManager.getPlotContainer().setAutoScaleEnabled(isAutoScaleOn, false);  // toggle autoscaling, but don't pad
      if (isAutoScaleOn) {
         autoScaleToggleButton.addClass("active");
      }
      else {
         autoScaleToggleButton.removeClass("active");
      }
   }

   function setSizes() {
      // Only show the y axis label if the grapher is tall enough.  If it is, then position it accordingly.
      var yAxisLabelElement = $("#y_axis_label");
      if ($("#plot_container").outerHeight() >= 150) {
         var yAxisElement = $("#y_axis");
         var yAxisWidth = yAxisElement.width();
         var yAxisHeight = yAxisElement.height();
         yAxisLabelElement.width(yAxisHeight); // set the width == height since we're rotating
         var yAxisLabelHeight = yAxisLabelElement.height();

         // compute the position of the y-axis label
         var yAxisLabelLeft = Math.round(yAxisWidth + yAxisLabelHeight / 2 - yAxisHeight / 2 + 2);
         var yAxisLabelTop = Math.round(yAxisHeight / 2 - yAxisLabelHeight / 2);

         // set position and then show it
         yAxisLabelElement
               .css("top", yAxisLabelTop + "px")
               .css("left", yAxisLabelLeft + "px")
               .show();
      }
      else {
         yAxisLabelElement.hide();
      }

      // Change the UI for the channel menu depending on window size.  First, define a function to expand or collapse
      // the channel switcher.  Then we explicitly set it to expanded so that we can get a measurement of its desired
      // size.  Then compute whether it's too big and collapse accordingly.
      var collapseOrExpandChannelSwitcher = function(isCollapsed) {
         $(".horizontal_list_or_menu_button_items")
               .toggleClass("dropdown-menu", isCollapsed)
               .toggleClass("horizontal-list", !isCollapsed);
         if (isCollapsed) {
            $(".menu_button").show();
         }
         else {
            $(".menu_button").hide();
         }
      };

      // force the channel switcher to be expanded so we can measure its desired width next
      collapseOrExpandChannelSwitcher(false);

      // measure the channel switcher's desired width, compute whether it will fit in the available space (with padding)
      // and then collapse or expand accordingly.  Not that if it should be expanded, we don't bother again here, since
      // we just did so above.
      var channelSwitcherMenuItemsWidth = $("#channel_switcher_menu_items").width();
      var autoScaleButtonWidth = $("#auto_scale_toggle_button").width();
      var grapherWidth = $("#grapher").width();
      var willCollapseToMenuButton = (channelSwitcherMenuItemsWidth + 30) > (grapherWidth - autoScaleButtonWidth);
      if (willCollapseToMenuButton) {
         collapseOrExpandChannelSwitcher(willCollapseToMenuButton);
      }
   }

   function doExport(willExportAllChannels) {
      var channels = willExportAllChannels ? Object.keys(selectedFeed.channelBounds.channels).sort().join(',') : selectedChannelName;
      var dateAxisRange = plotManager.getDateAxis().getRange();
      window.open(ESDR_API_ROOT_URL + "/feeds/" + selectedFeed.id + "/channels/" + channels + "/export?from=" + dateAxisRange.min + "&to=" + dateAxisRange.max, '_blank');
   }

   // This is annoying. We need to read the timestamp of the PM2.5 channel for govt feeds so we can determine whether
   // the data is stale and whether it's more recent than other feeds in the geocoded area.  But, since there are a
   // variety of channel names which all mean PM2.5, we need to check the feed for each one until we find the right
   // one.  And THEN, we return that channel's maxTimeSecs field. Dude.
   function getMaxTimeSecsOfGovtFeedPM25Channel(feed) {
      if (feed && feed.channelBounds && feed.channelBounds.channels) {
         for (var i = 0; i < GOVT_PM_2_5_CHANNEL_NAMES.length; i++) {
            var channelName = GOVT_PM_2_5_CHANNEL_NAMES[i];
            if (channelName in feed.channelBounds.channels) {
               return feed.channelBounds.channels[channelName].maxTimeSecs;
            }
         }
      }
      return null;
   }

   function findGovtFeedsWithinBoundingBox(boundingBox) {
      var center = boundingBox.getCenter();
      var currentTimeSecs = Date.now() / 1000;
      var sixHoursAgo = currentTimeSecs - SIX_HOURS_IN_SECONDS;

      var obj = {
         feeds : null,
         nearest : {
            feed : null,
            distanceKm : Number.MAX_VALUE,
            maxTimeSecs : -Number.MAX_VALUE
         },
         mostRecent : {
            feed : null,
            distanceKm : Number.MAX_VALUE,
            maxTimeSecs : -Number.MAX_VALUE
         }
      };

      var distanceByFeedId = {};
      var maxTimeSecsByFeedId = {};
      obj.feeds = govtFeeds.filter(function(feed) {
         var isContained = boundingBox.contains(feed.latLng);

         // if this feed is within the bounding box, see whether it's either the closest feed, or the one with the
         // most recent data
         if (isContained) {

            // only consider this feed if the data isn't stale (i.e. more than 6 hours old)
            var maxTimeSecs = getMaxTimeSecsOfGovtFeedPM25Channel(feed);
            if (maxTimeSecs > sixHoursAgo) {
               // compute the distance, but divide by 1000 to get kilometers
               var distanceKm = google.maps.geometry.spherical.computeDistanceBetween(center, feed.latLng) / 1000;

               // ignore this feed if it's not within the search radius (we want a circular radius, but the bounding
               // box containment check is rectangular)
               if (distanceKm < SEARCH_RADIUS_IN_KM) {
                  // check whether this is the new closest feed
                  if (distanceKm < obj.nearest.distanceKm) {
                     obj.nearest.feed = feed;
                     obj.nearest.distanceKm = distanceKm;
                     obj.nearest.maxTimeSecs = maxTimeSecs;
                  }

                  distanceByFeedId[feed.id] = distanceKm;
                  maxTimeSecsByFeedId[feed.id] = maxTimeSecs;

                  return true;
               }
            }
         }
         return false;
      });

      if (obj.feeds.length > 0) {
         // now that we have a subset of contained feeds with data that isn't stale, run through that subset and
         // see if any of them has data newer than the closest feed.
         obj.mostRecent.feed = obj.nearest.feed;
         obj.mostRecent.distanceKm = distanceByFeedId[obj.nearest.feed.id];
         obj.mostRecent.maxTimeSecs = maxTimeSecsByFeedId[obj.nearest.feed.id];
         obj.feeds.forEach(function(feed) {
            if (feed.id != obj.nearest.feed.id) {
               var maxTimeSecs = maxTimeSecsByFeedId[feed.id];
               // check whether this is the new most-recent feed
               if (maxTimeSecs > obj.mostRecent.maxTimeSecs) {
                  obj.mostRecent.feed = feed;
                  obj.mostRecent.distanceKm = distanceByFeedId[feed.id];
                  obj.mostRecent.maxTimeSecs = maxTimeSecs;
               }
            }
         });
      }

      return obj;
   }

   function getMostRecentDataSample(feed, callback) {
      var channelName = "PM2_5";

      // find the PM2.5 channel name for this feed
      for (var i = 0; i < GOVT_PM_2_5_CHANNEL_NAMES.length; i++) {
         var name = GOVT_PM_2_5_CHANNEL_NAMES[i];
         if (name in feed.channelBounds.channels) {
            channelName = name;
            break;
         }
      }

      superagent
            .get(ESDR_API_ROOT_URL + "/feeds/" + feed.id + "/channels/" + channelName + "/most-recent")
            .end(function(err, res) {
               if (err) {
                  callback(err);
               }
               else {
                  // got the data
                  if (res.body.code == 200                   &&
                      typeof res.body.data !== 'undefined'   &&
                      res.body.data != null                  &&
                      res.body.data['channels']              &&
                      res.body.data['channels']              &&
                      res.body.data['channels'][channelName] &&
                      res.body.data['channels'][channelName]['mostRecentDataSample']
                  ) {
                     var dataSample = res.body.data['channels'][channelName]['mostRecentDataSample'];
                     dataSample.timeStr = new Date(dataSample.timeSecs * 1000).toTimeString();
                     callback(null, dataSample);
                  }
                  else {
                     callback(new Error("Failed to get most recent value for for feed.channel [" + feed.id + "." + channelName + "]"));
                  }
               }
            });
   }

   function displayGeocodeResults(address, latLng, results) {
      var template = null;
      var templateOptions = null;
      if (results) {
         if (results.feeds.length > 0) {
            if (results.nearest.feed.id == results.mostRecent.feed.id) {
               return getMostRecentDataSample(results.nearest.feed, function(err, dataSample) {
                  template = Handlebars.templates['public_data_geocode_found_one'];
                  templateOptions = {
                     dataSample : dataSample,
                     nearest : results.nearest.feed
                  };
                  $("#results").empty().append($(template(templateOptions)));
               });
            }
            else {

               var nearestDataSample = null;
               var mostRecentDataSample = null;
               return _.parallel(
                     [
                        function(done) {
                           getMostRecentDataSample(results.nearest.feed, function(err, dataSample) {
                              nearestDataSample = dataSample;
                              done();
                           });
                        },
                        function(done) {
                           getMostRecentDataSample(results.mostRecent.feed, function(err, dataSample) {
                              mostRecentDataSample = dataSample;
                              done();
                           });
                        }
                     ],
                     function() {
                        var distanceDiff = results.mostRecent.distanceKm - results.nearest.distanceKm;
                        var distanceDiffKm = distanceDiff.toFixed(2);
                        var distanceDiffMi = (distanceDiff * 0.621371).toFixed(2);
                        var timeDiff = ((results.mostRecent.maxTimeSecs - results.nearest.maxTimeSecs) / 3600).toFixed(1);
                        timeDiff = (Math.round(timeDiff) == timeDiff) ? Math.round(timeDiff) : timeDiff;

                        template = Handlebars.templates['public_data_geocode_found_two'];
                        templateOptions = {
                           nearest : results.nearest.feed,
                           nearestDataSample : nearestDataSample,
                           mostRecent : results.mostRecent.feed,
                           mostRecentDataSample : mostRecentDataSample,
                           distanceDiffKm : distanceDiffKm,
                           distanceDiffMi : distanceDiffMi,
                           timeDiff : timeDiff,
                           hourPlurality : (timeDiff <= 1 ? '' : 's')
                        };
                        $("#results").empty().append($(template(templateOptions)));

                     }
               );
            }
         }
         else {
            template = Handlebars.templates['public_data_no_nearby_stations'];
         }
      }
      else {
         template = Handlebars.templates['public_data_geocode_failed'];
         map.setCenter(MAP_CENTER);
         map.setZoomLevel(getDefaultMapZoomLevel());
         setGeolocationMarkerLocation(null);
      }

      $("#results").empty().append($(template(templateOptions)));
   }

   function setGeolocationMarkerLocation(latLng) {
      // move the marker (if any) to the newly geocoded location
      if (geocodedLocationMarker != null) {
         geocodedLocationMarker.setMap(null);
      }
      if (latLng instanceof google.maps.LatLng) {
         geocodedLocationMarker = new google.maps.Marker({
            position : latLng,
            map : map.getWrappedMap()
         });
      }
   }

   function geocodeAddress(address) {
      map.geocodeAddress(address, function(err, latLng, results) {
         if (err) {
            console.log(err);
            setFeedSelected(null);
            displayGeocodeResults(address, null, null);
         }
         else {
            console.log("Geocoded [" + address + "] --> " + latLng.toString());
            map.setCenter(latLng);
            map.setZoomLevel(12);

            // move the marker to the newly geocoded location
            setGeolocationMarkerLocation(latLng);
            var boundingBox = map.getBoundingBoxAroundLocation(latLng, SEARCH_RADIUS_IN_KM);
            var foundFeeds = findGovtFeedsWithinBoundingBox(boundingBox);

            // if we found a feed in the search area, then fit the geocoded location, the nearest found feed, and the
            // feed with the most-recent data on the map
            if (foundFeeds.feeds.length > 0) {
               setFeedSelected(foundFeeds.nearest.feed.id);
               map.fitMapBoundsToLocations([latLng, foundFeeds.nearest.feed.latLng, foundFeeds.mostRecent.feed.latLng]);
            }
            else {
               setFeedSelected(null);
               map.fitBounds(boundingBox);
            }

            displayGeocodeResults(address, latLng, foundFeeds);
         }
      });
   }

</script>
<div id="public_data_page">
   <h2>Public Data</h2>
   <div class="row">
      <div id="instructions" class="col-xs-12">
         <p>
            This map shows the locations of regulated PM<sub>2.5</sub> stations and all public Specks. Enter an address
            or location to find the nearest regulated station and see the current and historical air quality. Or, select
            a marker on the map to see a plot of the air quality at that location.
         </p>
         <div class="geocode_form_container">
            <form class="geocode_form" action="/public-data" method="get" style="display:none"></form>
            <div class="input-group">
               <input type="text" class="form-control geocode_location" placeholder="Search for an address or location"/>
               <span class="input-group-btn">
                 <button class="btn btn-default geocode_submit_button" type="button"><i class="fa fa-search"></i>
                 </button>
               </span>
            </div>
         </div>
      </div>
      <div id="results" class="col-xs-12"></div>
   </div>
   <div class="row">
      <div id="map_container" class="noselect col-sm-12">
         <div id="map_area"></div>
         <div id="map_filters_area">
            <div class="map_filter">
               <input type="checkbox" id="govt_feed_checkbox" class="feed_filter" name="govt_feed_checkbox" checked="checked"/>
               <label for="govt_feed_checkbox">Regulated PM<sub>2.5</sub> Stations</label>
            </div>
            <div class="map_filter">
               <input type="checkbox" id="outdoor_speck_checkbox" class="feed_filter" name="outdoor_speck_checkbox" checked="checked"/>
               <label for="outdoor_speck_checkbox">Outdoor Specks</label>
            </div>
            <div class="map_filter">
               <input type="checkbox" id="indoor_speck_checkbox" class="feed_filter" name="indoor_speck_checkbox" checked="checked"/>
               <label for="indoor_speck_checkbox">Indoor Specks</label>
            </div>
         </div>
      </div>
      <div id="grapher_container" class="noselect col-sm-12">
         <div id="selected_feed_name_label">
            <div class="feed_name_label grapher_item"></div>
         </div>
         <table id="grapher" class="grapher_item" border="0" cellpadding="0" cellspacing="0" style="display:none">
            <tr>
               <td>
                  <div id="date_axis" class="date_axis"></div>
               </td>
               <td align="center" valign="bottom">
                  <div id="export_button_container" class="btn-group">
                     <button id="export_button" type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-expanded="false" title="Download your data">
                        <i class="fa fa-cloud-download"></i>
                     </button>
                     <ul id="export_button_menu" class="dropdown-menu dropdown-menu-right" role="menu">
                        <li><a id="export_this_channel_button" href="#">This Channel</a></li>
                        <li><a id="export_all_channels_button" href="#">All Channels</a></li>
                     </ul>
                  </div>
               </td>
            </tr>
            <tr>
               <td>
                  <div id="plot_container" class="plot_container" style="height:300px; border: 1px solid black;">
                     <div id="value_and_time"></div>
                  </div>
               </td>
               <td>
                  <div id="y_axis" class="y_axis" style="height:300px">
                     <div id="y_axis_label" class="rotate_90 y_axis_label">&nbsp;</div>
                  </div>
               </td>
            </tr>
            <tr>
               <td colspan="2" align="right">
                  <div id="grapher_toolbar_bottom" class="grapher_toolbar">
                     <div class="pull-left">
                        <div id="channel_switcher_menu" class="horizontal_list_or_menu_button btn-group dropup">
                           <button type="button" class="menu_button btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown" aria-expanded="false">
                              <span id="channel_switcher_menu_label"></span> <span class="caret"></span>
                           </button>
                           <ul id="channel_switcher_menu_items" class="horizontal_list_or_menu_button_items dropdown-menu" role="menu"></ul>
                        </div>
                     </div>

                     <div class="btn-group pull-right">
                        <a id="auto_scale_toggle_button" class="btn btn-default btn-sm active" href="#" onclick="toggleYAxisAutoScaling(); return false;" title="Toggle Y axis auto-scaling">Auto Scale</a>
                     </div>
                  </div>
               </td>
            </tr>
         </table>
      </div>
   </div>
</div>