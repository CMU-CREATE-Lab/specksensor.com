<link href="/css/grapher.css" rel="stylesheet" type="text/css"/>
<style type="text/css">
   body {
      overflow-x: hidden;
   }
</style>
<script src="https://maps.googleapis.com/maps/api/js?key={{{googleMapsApiKey}}}" type="text/javascript"></script>
<script src="/lib/canvas-layer/src/CanvasLayer.js" type="text/javascript"></script>
<script src="/js/com/specksensor/geo/Map.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/jquery-mousewheel/jquery.mousewheel.min.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/createlab-grapher/grapher.min.js" type="text/javascript"></script>
<script src="{{esdrUrl}}/lib/plot-manager/org/bodytrack/grapher/PlotManager.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">

   var ESDR_API_ROOT_URL = '{{esdrUrl}}/api/v1';

   var PRODUCT_ID = '{{speckProductId}}';

   var DEFAULT_CHANNEL_NAMES = ["particle_count", "particle_concentration"];
   var DARK_BLUE_COLOR = "#2e68a3";
   var SEVEN_DAYS_IN_SECS = 604800;

   var MEDIUM_DEVICE_WIDTH_PIXELS = 992;
   var SMALL_DEVICE_WIDTH_PIXELS = 768;
   var MIN_GRAPHER_HEIGHT = 50;
   var MAX_GRAPHER_HEIGHT = 300;

   var esdr = null;

   var feedsById = {};
   var deviceNamesById = {};
   var selectedFeed = null;
   var selectedChannelName = DEFAULT_CHANNEL_NAMES[0];

   // grapher stuff
   var plotManager;
   var currentDateAxisRange = { min : null, max : null };

   // map stuff
   var map = new com.specksensor.geo.Map("map_area");

   // marker rendering
   var SELECTED_MARKER_COLOR = "#ff0000";
   var POINT_RADIUS_HAS_DATA = 6;
   var POINT_RADIUS_NO_DATA = 4;
   var TWO_PI = 2 * Math.PI;

   //Mike
   var cbmode = 0;
   var boxen = {};
   var boxenColors = ['#1a9850', '#91cf60', '#d9ef8b', '#fee08b', '#fc8d59', '#d73027'];
   var boxenConcentrationLevels = [0, 20, 40, 80, 160, 320];

   var boxenCBColors = ["#4575b4", "#91bfdb", "#e0f3f8", "#fee090", "#fc8d59", "#d73027"];
   var boxenCountLevels = [0, 500, 1000, 2000, 4000, 8000];
   var boxenAxisChangeListener = null;

   var availablePlotColors = ["#990000", "#009900", "#000099", "#999900", "#6600ff"];
   var usedPlotColorsByDeviceId = {};

   var timeRangeOptions = [
      {
         "label" : "All Data",
         "handler" : function() {
            plotManager.getDateAxis().setRange(selectedFeed.minTimeSecs, selectedFeed.maxTimeSecs);
         }
      },
      {
         "label" : "Past 30 Days",
         "handler" : function() {
            setRangeFromSecondsAgoToNow(2592000);
         }
      },
      {
         "label" : "Past 7 Days",
         "handler" : function() {
            setRangeFromSecondsAgoToNow(SEVEN_DAYS_IN_SECS);
         }
      },
      {
         "label" : "Past 24 Hours",
         "handler" : function() {
            setRangeFromSecondsAgoToNow(86400);
         }
      },
      {
         "label" : "Past 12 Hours",
         "handler" : function() {
            setRangeFromSecondsAgoToNow(43200);
         }
      },
      {
         "label" : "Past Hour",
         "handler" : function() {
            setRangeFromSecondsAgoToNow(3600);
         }
      }
   ];

   window.grapherLoad = function() {
      var accessToken = new com.specksensor.AccessToken();

      // try fetching the access token
      accessToken.load(function(err, token) {

         esdr = new org.cmucreatelab.esdr.ESDR(token);

         // first load the devices, sorted by name
         esdr.devices.find("?where=userId={{user.esdrUserId}},productId=" + PRODUCT_ID + "&orderBy=name&fields=id,name",
               {
                  success : function(foundDevices) {
                     if (foundDevices && foundDevices.rows && foundDevices.rows.length > 0) {
                        var devices = foundDevices.rows;
                        // now load all the feeds
                        esdr.feeds.find("?where=userId={{user.esdrUserId}},productId=" + PRODUCT_ID + ",minTimeSecs<>__null__&orderBy=-lastUpload&fields=id,userId,name,deviceId,apiKeyReadOnly,isPublic,latitude,longitude,channelSpecs,channelBounds,lastUpload,minTimeSecs,maxTimeSecs",
                              {
                                 success : function(foundFeeds) {
                                    if (foundFeeds && foundFeeds.rows && foundFeeds.rows.length > 0) {

                                       // pick the first feed as the default selected feed since
                                       // it received the most recent upload
                                       selectedFeed = foundFeeds.rows[0];

                                       // set a flag in the form of a CSS class which the CSS rules can use to change
                                       // rendering behavior depending on whether the user has one or many feeds.
                                       var contentAreaElement = $("#content_area");
                                       if (foundFeeds.rows.length == 1) {
                                          contentAreaElement.addClass('has_only_one_feed');
                                       }
                                       else {
                                          contentAreaElement.addClass('has_multiple_feeds');
                                       }

                                       // sort the feeds by deviceId
                                       var feedsByDeviceId = {};
                                       foundFeeds.rows.forEach(function(feed) {
                                          feedsById[feed.id] = feed;
                                          feed.lastUploadFormatted = (feed.minTimeSecs == null || feed.maxTimeSecs == null) ? "never" : new Date(feed.lastUpload).toLocaleDateString() + " at " + new Date(feed.lastUpload).toLocaleTimeString();
                                          if (!(feed.deviceId in feedsByDeviceId)) {
                                             feedsByDeviceId[feed.deviceId] = [];
                                          }
                                          feedsByDeviceId[feed.deviceId].push(feed);
                                       });

                                       // build the devices and feeds menus
                                       var deviceAndFeedsSidebarMenuItemTemplate = Handlebars.templates['dashboard_device_and_feeds_sidebar_menu_item'];
                                       var deviceAndFeedsDropdownMenuItemTemplate = Handlebars.templates['dashboard_device_and_feeds_dropdown_menu_item'];
                                       devices.forEach(function(device) {
                                          device.feeds = feedsByDeviceId[device.id];
                                          deviceNamesById[device.id] = device.name;

                                          // don't show devices here which have no feeds
                                          if (device.feeds && device.feeds.length > 0) {
                                             $("#devices_and_feeds_sidebar_menu").append($(deviceAndFeedsSidebarMenuItemTemplate(device)));
                                             var dropdownMenuItemElement = $(deviceAndFeedsDropdownMenuItemTemplate(device));
                                             $("#devices_and_feeds_dropdown_menu").append(dropdownMenuItemElement);
                                          }
                                       });

                                       // add the click handler for the radio buttons
                                       $(".feed_radio_button").click(function() {
                                          var feedId = $(this).val();
                                          setFeedSelected(feedId);
                                       });

                                       $("#devices_and_feeds_dropdown_menu").find(".feed").click(function() {
                                          var feedId = $(this).attr('feedId');
                                          setFeedSelected(feedId);
                                       });

                                       contentAreaElement.show();
                                       map.initialize(
                                             {
                                                styles : [
                                                   {
                                                      featureType : "poi",
                                                      elementType : "labels",
                                                      stylers : [
                                                         { visibility : "off" }
                                                      ]
                                                   }
                                                ]
                                             },
                                             {
                                                searchDistanceFromMarkerInPixels : 5
                                             },
                                             {
                                                handleInitializationComplete : function() {
                                                   initializeGrapher();
                                                   initializeMarkers();
                                                   map.fitMapBoundsToMarkers();
                                                },
                                                handleMarkerSelected : function(marker) {
                                                   setFeedSelected(marker.id);
                                                }
                                             }
                                       );
                                    }
                                    else {
                                       showHasNoDataMessage('has_no_feeds_panel');
                                    }
                                 },
                                 validationError : function(errors) {
                                    // TODO
                                    console.log("Validation error while trying to load feeds for device ID [" + deviceId + "]: " + JSON.stringify(errors, null, 3));
                                 },
                                 error : function(responseBody, httpStatusCode) {
                                    // TODO: some other error
                                    console.log("Error: Unexpected error (HTTP status " + httpStatusCode + ") while trying to load feeds for device ID [" + deviceId + "]: " + JSON.stringify(responseBody, null, 3));
                                 },
                                 failure : function(err, httpStatusCode) {
                                    // TODO: some other error
                                    console.log("Error: Unexpected failure (HTTP status " + httpStatusCode + ") while trying to load feeds for device ID [" + deviceId + "]: " + err);
                                 }
                              });
                     }
                     else {
                        showHasNoDataMessage('has_no_devices_panel');
                     }
                  },
                  unauthorized : function() {
                     // TODO:
                     console.log("Unauthorized");
                  },
                  validationError : function(errors) {
                     // TODO
                     console.log("Validation error while trying to load devices owned by the user: " + JSON.stringify(errors, null, 3));
                  },
                  error : function(responseBody, httpStatusCode) {
                     // TODO: some other error
                     console.log("Error: Unexpected error (HTTP status " + httpStatusCode + ") while trying to load devices owned by the user: " + JSON.stringify(responseBody, null, 3));
                  },
                  failure : function(err, httpStatusCode) {
                     // TODO: some other error
                     console.log("Error: Unexpected failure (HTTP status " + httpStatusCode + ") while trying to load devices owned by the user: " + err);
                  }
               });
      });
   };

   function showHasNoDataMessage(divToShow) {
      $("#loading_panel").hide();
      $("#" + divToShow).show();
   }

   function initializeGrapher() {
      console.log("In initializeGrapher()");

      var unselectAllTimeRangeMenuItems = function() {
         $("#time_range_switcher_menu").find(".menu_item").find(".selected").removeClass('selected').addClass('unselected');
         $("#time_range_switcher_menu_label").text("Time Range");
      };

      // render the time range options
      var timeRangeMenuItemTemplate = Handlebars.templates['grapher_time_range_menu_item'];
      timeRangeOptions.forEach(function(timeRangeOption, index) {
         var timeRangeElement = $(timeRangeMenuItemTemplate({
            index : index,
            label : timeRangeOption.label,
            cssClass : 'unselected'
         }));
         timeRangeElement.click(timeRangeOption.handler).click(function() {
            unselectAllTimeRangeMenuItems();
            var anchorElement = $(this).find('a');
            anchorElement.removeClass('unselected').addClass('selected');
            $("#time_range_switcher_menu_label").text(anchorElement.text());
         });
         $("#time_range_switcher_menu_items").append(timeRangeElement);
      });
      $("#time_range_switcher_menu").show();

      var now = new Date();
      var midnight = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      var channelMinTimeSecs = midnight.getTime() / 1000;
      var channelMaxTimeSecs = now.getTime() / 1000;

      // Grapher is not happy if min time equals max time.  Adjust them if necessary
      if (channelMinTimeSecs == channelMaxTimeSecs) {
         channelMinTimeSecs--;
         channelMaxTimeSecs++;
      }

      plotManager = new org.bodytrack.grapher.PlotManager("date_axis", channelMinTimeSecs, channelMaxTimeSecs);
      plotManager.setWillAutoResizeWidth(true, function() {
         return $("#content_area").width()         // window width
                - $(".y_axis").width()             // Y axis width
                //- $("#y_axis_label").height()      // the height of the Y axis label
                //- 5                                // right margin
                - 3;                               // grapher and Y axis borders
      });

      plotManager.getDateAxis().addAxisChangeListener(function(axisChangeEvent) {
         var hasDateRangeChanged = currentDateAxisRange.min != axisChangeEvent.min ||
                                   currentDateAxisRange.max != axisChangeEvent.max;

         // remember the new date range
         currentDateAxisRange = {
            min : axisChangeEvent.min,
            max : axisChangeEvent.max
         };

         // If the user is fiddling with the date axis, then mark all time range options as unselected.  But! Don't
         // unselect time range items if the axis range didn't change (e.g. cursor event of mousing out of the window)
         if (hasDateRangeChanged) {
            unselectAllTimeRangeMenuItems();
         }
      });

      // create the plot container so that we can turn autoscaling on by default (but don't pad)
      plotManager.addPlotContainer("plot_container").setAutoScaleEnabled(true, false);

      addFeedToGrapher(selectedFeed);

      $("#export_this_channel_button").click(function() {
         doExport(false);
         return false;
      });
      $("#export_all_channels_button").click(function() {
         doExport(true);
         return false;
      });

      $("#loading_panel").hide();
      $("#grapher_container").show();

      setSizes();

      // set up window resize handler
      $(window).resize(setSizes);
   }

   function doExport(willExportAllChannels) {
      var idOrApiKey = selectedFeed.isPublic ? selectedFeed.id : selectedFeed.apiKeyReadOnly;
      var channels = willExportAllChannels ? Object.keys(selectedFeed.channelBounds.channels).sort().join(',') : selectedChannelName;
      var dateAxisRange = plotManager.getDateAxis().getRange();
      window.open(ESDR_API_ROOT_URL + "/feeds/" + idOrApiKey + "/channels/" + channels + "/export?from=" + dateAxisRange.min + "&to=" + dateAxisRange.max, '_blank');
   }

   function initializeMarkers() {
      var getMarkerIdForFeed = function(feed) {
         return feed.id;
      };

      Object.keys(feedsById).forEach(function(feedId) {
         var feed = feedsById[feedId];
         var latitude = feed['latitude'];
         var longitude = feed['longitude'];
         if (latitude != null && longitude != null) {
            var latLong = new google.maps.LatLng(feed['latitude'], feed['longitude']);
            map.addMarker(getMarkerIdForFeed(feed), latLong, renderMarker);
         }
      });

      // select the marker corresponding to the currently selected feed
      setFeedSelected(selectedFeed.id);
   }

   function renderMarker(marker, canvasPosition, context) {
      var isNoData = marker['value'] == null;
      var radius = (isNoData ? POINT_RADIUS_NO_DATA : POINT_RADIUS_HAS_DATA);

      if (selectedFeed.id == marker.id) {
         context.beginPath();
         context.arc(canvasPosition.x, canvasPosition.y, radius + 1, 0, TWO_PI, false);
         context.lineWidth = 2;
         context.strokeStyle = SELECTED_MARKER_COLOR;
         context.stroke();
      }

      // draw a circle
      context.beginPath();
      context.arc(canvasPosition.x, canvasPosition.y, radius, 0, TWO_PI, false);
      context.fillStyle = "rgba(10, 10, 10, 0.6)";
      context.fill();
   }

   function setFeedSelected(feedId) {
      // make sure the appropriate radio button is selected (the user might have clicked a map marker)
      $('#feed_radio_button_' + feedId).prop('checked', true);

      // uncheck all menu items in the devices and feeds dropdown menu and then check the selected one
      $("#devices_and_feeds_dropdown_menu").find(".feed-icon").removeClass('fa-check').addClass('placeholder');
      $('#feed_menu_item_' + feedId).find('.feed-icon').removeClass('placeholder').addClass('fa-check');

      var feed = feedsById[feedId];
      $(".device_name_label").text(deviceNamesById[feed.deviceId]);
      $(".feed_name_label").text(feed.name);

      if (selectedFeed.id != feedId) {

         // remove the current feed from the grapher (if any)
         removeFeedFromGrapher(selectedFeed);

         $("#no_geolocation").hide();

         selectedFeed = feed;

         if (selectedFeed.latitude == null || selectedFeed.longitude == null) {
            $("#no_geolocation").show();
         }

         // update the grapher
         addFeedToGrapher(selectedFeed);

         // update markers
         map.renderMarkers();
      }
   }

   function removeFeedFromGrapher(feed) {
      if (feed) {
         var plotId = feed.id;

         // make sure to remove the Y axis change listener (if we don't, then it'll hang around and still get called
         // when moving the mouse outside the window)
         var yAxis = plotManager.getYAxis();
         if (yAxis != null) {
            yAxis.removeAxisChangeListener(boxenAxisChangeListener);
         }

         plotManager.getPlotContainer().removePlot(plotId);

         $("#y_axis_label").empty();
         $("#channel_switcher_menu_items").empty();
         $("#value_and_time").empty();
         $(".color_box").hide();
      }
   }

   function isChannelInChannelSpecs(channelSpecs, channelName) {
      if (channelSpecs) {
         // deal with different versions of channelSpecs
         var version = channelSpecs.version || -1;
         switch (version) {
            case 1:
               return ("channels" in channelSpecs && channelName in channelSpecs['channels']);
               break;
            default:
               return channelName in channelSpecs;
         }
      }

      return false;
   }

   function getChannelPropertyFromChannelSpecs(channelSpecs, channelName, propertyName) {
      if (channelSpecs) {
         // deal with different versions of channelSpecs
         var version = channelSpecs.version || 0;
         switch (version) {
            case 1:
               if ("channels" in channelSpecs && channelName in channelSpecs['channels']) {
                  return channelSpecs["channels"][channelName][propertyName];
               }
               break;
            default:
               if (channelName in channelSpecs) {
                  return channelSpecs[channelName][propertyName];
               }
         }
      }

      return undefined;
   }

   function addFeedToGrapher(feed, willPreserveDateAxis) {
      if (feed) {
         willPreserveDateAxis = !!willPreserveDateAxis;

         // Since different feeds can have different sets of channels, we need to make sure that the selectedChannelName
         // actually exists in the new feed.  If not, try the DEFAULT_CHANNEL_NAMES or, if that fails too, then just use
         // the first channel (alphabetically)
         if (!(selectedChannelName in feed.channelBounds.channels)) {
            var channelNameToUse = null;
            for (var i = 0; i < DEFAULT_CHANNEL_NAMES.length; i++) {
               var channelName = DEFAULT_CHANNEL_NAMES[i];
               if (channelName in feed.channelBounds.channels) {
                  channelNameToUse = channelName;
                  break;
               }
            }
            if (channelNameToUse != null) {
               selectedChannelName = channelNameToUse;
            }
            else {
               selectedChannelName = Object.keys(feed.channelBounds.channels).sort()[0];
            }
         }

         if (!willPreserveDateAxis) {
            // If we're not preserving the time range, then try to show up to 7 days of history.  See inline comments
            // for details about the logic...

            var now = Date.now() / 1000;
            var sevenDaysAgoBeforeMax = now - SEVEN_DAYS_IN_SECS;

            var channelMinTimeSecs = feed.channelBounds.channels[selectedChannelName].minTimeSecs;
            var channelMaxTimeSecs = feed.channelBounds.channels[selectedChannelName].maxTimeSecs;

            // if the feed's most recent data is older than 7 days ago, then make the max time on the date axis equal
            // to the channel's max time.  Otherwise, just set it to now.
            var max = now;
            if (channelMaxTimeSecs < sevenDaysAgoBeforeMax) {
               max = channelMaxTimeSecs;

               // recompute the sevenDaysAgoBeforeMax, since we've changed the max
               sevenDaysAgoBeforeMax = max - SEVEN_DAYS_IN_SECS;
            }

            // set the date range's min to either the channel's min time, or 7 days ago before the max time computed
            // above, whichever is more recent.
            var min = Math.max(channelMinTimeSecs, sevenDaysAgoBeforeMax);

            // Grapher is not happy if min time equals max time.  Adjust them if necessary
            if (min == max) {
               min--;
               max++;
            }

            plotManager.getDateAxis().constrainRangeTo(channelMinTimeSecs, now);
            plotManager.getDateAxis().setRange(min, max);
         }

         var isParticleConcentrationChannel = (selectedChannelName == "particle_concentration");
         var isParticleCountChannel = (selectedChannelName == "particle_count");
         var isShowingColoredRanges = (isParticleConcentrationChannel || isParticleCountChannel);

         // set the Y axis label
         var channelUnits = null;
         var yAxisLabel = null;
         var prettyName = selectedChannelName;
         if (isChannelInChannelSpecs(feed['channelSpecs'], selectedChannelName)) {
            prettyName = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], selectedChannelName, 'prettyName');
            var units = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], selectedChannelName, 'units');
            if (prettyName) {
               yAxisLabel = prettyName;
            }
            if (units) {
               channelUnits = units;
               yAxisLabel += " (" + units + ")";
            }
         }
         else {
            yAxisLabel = selectedChannelName;
         }
         $("#y_axis_label").text(yAxisLabel == null ? "" : yAxisLabel);

         // set the channel menu button label to the currently-selected channel name
         $("#channel_switcher_menu_label").text(prettyName);

         // render the links to change channels
         $("#channel_switcher_menu_items").empty();
         if (feed['channelBounds'] && feed['channelBounds']['channels']) {
            var availableChannels = Object.keys(feed['channelBounds']['channels']).sort();
            if (!(selectedChannelName in feed['channelBounds']['channels'])) {
               selectedChannelName = availableChannels[0];
            }

            var channelNameMenuItemTemplate = Handlebars.templates['grapher_channel_menu_item'];
            availableChannels.forEach(function(channelName) {
               var prettyChannelName = channelName;
               if (isChannelInChannelSpecs(feed['channelSpecs'], channelName)) {
                  prettyChannelName = getChannelPropertyFromChannelSpecs(feed['channelSpecs'], channelName, 'prettyName');
               }
               var selectionStateClass = (channelName == selectedChannelName) ? 'selected' : 'unselected';

               var menuItemElement = $(channelNameMenuItemTemplate({
                  channelName : prettyChannelName,
                  cssClass : selectionStateClass
               }));

               // add click event handler to the channel change links
               if (channelName != selectedChannelName) {
                  menuItemElement.click(function() {
                     // update the grapher to show the newly selected channel
                     selectedChannelName = channelName;
                     removeFeedFromGrapher(selectedFeed);
                     addFeedToGrapher(selectedFeed, true);
                  });
               }
               $("#channel_switcher_menu_items").append(menuItemElement);
            });
         }

         var plotId = feed.id;
         plotManager.addDataSeriesPlot(plotId,
                                       function(level, offset, successCallback) {
                                          esdr.tiles.get(feed.apiKeyReadOnly, selectedChannelName, level, offset, {
                                             success : function(json) {
                                                successCallback(json);
                                             },
                                             unauthorized : function() {
                                                // TODO:
                                                console.log("Unauthorized");
                                             },
                                             forbidden : function() {
                                                // TODO:
                                                console.log("Forbidden");
                                             },
                                             error : function(responseBody) {
                                                // TODO:
                                                console.log("Error: " + responseBody);
                                             }
                                          });
                                       },
                                       "plot_container",
                                       "y_axis",
                                       feed.channelBounds.channels[selectedChannelName].minValue,
                                       feed.channelBounds.channels[selectedChannelName].maxValue);

         plotManager.getPlot(plotId).addDataPointListener(function(val) {
            var valueAndTimeElement = $("#value_and_time");
            if (val == null) {
               valueAndTimeElement.empty().hide();
            }
            else {
               valueAndTimeElement.text(val.valueString + (channelUnits == null ? "" : " " + channelUnits) + " at " + val.dateString).show();
            }
         });

         // TODO: add this back once the CREATE Lab grapher supports styles
         //plotManager.getPlot(plotId).setStyle({
         //   "styles" : [
         //      {
         //         "type" : "line",
         //         "lineWidth" : 1,
         //         "show" : true,
         //         "color" : (isShowingColoredRanges ? 'black' : DARK_BLUE_COLOR)
         //      },
         //      {
         //         "type" : "circle",
         //         radius : 1,
         //         "lineWidth" : 1,
         //         "show" : true,
         //         "color" : isShowingColoredRanges ? 'black' : DARK_BLUE_COLOR,
         //         fill : true
         //      }
         //   ],
         //   "highlight" : {
         //      "lineWidth" : 1,
         //      "styles" : [
         //         {
         //            "type" : "circle",
         //            radius : 3,
         //            "lineWidth" : 0.5,
         //            "show" : true,
         //            "color" : isShowingColoredRanges ? 'white' : 'black',
         //            fill : false
         //         },
         //         {
         //            "show" : true,
         //            "type" : "value",
         //            "fillColor" : isShowingColoredRanges ? 'white' : 'black',
         //            "marginWidth" : 10,
         //            "font" : "7pt Helvetica,Arial,Verdana,sans-serif",
         //            "verticalOffset" : 7,
         //            "numberFormat" : "###,##0.##"
         //         }
         //      ]
         //   }
         //});

         //Mike keeps breaking code
         if (cbmode) {
            boxen.colors = boxenCBColors;
         }
         else {
            boxen.colors = boxenColors;
         }

         var yAxis = plotManager.getYAxis();
         yAxis.removeAxisChangeListener(boxenAxisChangeListener);
         boxenAxisChangeListener = null;
         if (isParticleConcentrationChannel) {
            boxen.levels = boxenConcentrationLevels;
            yAxis.constrainRangeTo(0, 640, true);
            boxenAxisChangeListener = function() {
               adjustBoxen(boxen, "#plot_container");
            };
            yAxis.addAxisChangeListener(boxenAxisChangeListener);
         }
         else if (isParticleCountChannel) {
            boxen.levels = boxenCountLevels;
            yAxis.constrainRangeTo(0, 16000, true);
            boxenAxisChangeListener = function() {
               adjustBoxen(boxen, "#plot_container");
            };
            yAxis.addAxisChangeListener(boxenAxisChangeListener);
         }
         else {
            yAxis.constrainRangeTo(-1 * Number.MAX_VALUE, Number.MAX_VALUE);
         }

         removeBoxen();
         if (isShowingColoredRanges) {
            drawBoxen(boxen, "#plot_container");
            adjustBoxen(boxen, "#plot_container");
         }

         setSizes();
      }
   }

   function toggleYAxisAutoScaling() {
      var autoScaleToggleButton = $("#auto_scale_toggle_button");
      var isAutoScaleOn = !autoScaleToggleButton.hasClass("active");
      plotManager.getPlotContainer().setAutoScaleEnabled(isAutoScaleOn, false);  // toggle autoscaling, but don't pad
      if (isAutoScaleOn) {
         autoScaleToggleButton.addClass("active");
      }
      else {
         autoScaleToggleButton.removeClass("active");
      }
   }

   function setSizes() {
      var windowWidth = $(window).width();

      // adjust the grapher's height depending on window height, but only if the window is narrow
      if (windowWidth < SMALL_DEVICE_WIDTH_PIXELS) {
         var heightOfEverythingElse = $("#dashboard").height() - $("#plot_container").outerHeight();

         // compute the new plot container height by starting with the window height, and then subtracing away
         // the height of everything else that's not the plot container
         var newPlotContainerHeight = $(window).height()
                                      - 100                       // top and bottom navbars
                                      - 30                        // top and bottom padding
                                      - heightOfEverythingElse;   // everything in #dashboard that's not plot_container
         newPlotContainerHeight = Math.max(MIN_GRAPHER_HEIGHT, Math.min(newPlotContainerHeight, MAX_GRAPHER_HEIGHT));

         plotManager.getPlotContainer().setHeight(newPlotContainerHeight);
      }

      // Only show the y axis label if the grapher is tall enough.  If it is, then position it accordingly.
      var yAxisLabelElement = $("#y_axis_label");
      if ($("#plot_container").outerHeight() >= 150) {
         var yAxisElement = $("#y_axis");
         var yAxisWidth = yAxisElement.width();
         var yAxisHeight = yAxisElement.height();
         yAxisLabelElement.width(yAxisHeight); // set the width == height since we're rotating
         var yAxisLabelHeight = yAxisLabelElement.height();

         // compute the position of the y-axis label
         var yAxisLabelLeft = Math.round(yAxisWidth + yAxisLabelHeight / 2 - yAxisHeight / 2 + 2);
         var yAxisLabelTop = Math.round(yAxisHeight / 2 - yAxisLabelHeight / 2);

         // set position and then show it
         yAxisLabelElement
               .css("top", yAxisLabelTop + "px")
               .css("left", yAxisLabelLeft + "px")
               .show();
      }
      else {
         yAxisLabelElement.hide();
      }

      // update the map so it's the same width at the grapher
      map.setWidth($("#grapher").width() - 2);   // subtract 2 to account for the borders

      //Mike can't be stopped
      sizeBoxen(boxen, "#plot_container", 0);

      // Change the UI for the time range menu and channel menu depending on window size and whether the user
      // has multiple feeds.  Having multiple feeds matters because the sidebar menu is only shown when there
      // are multiple feeds, which makes the grapher area narrower, and thus there's less room for these
      // lists of links.
      var TINY_DEVICE_WIDTH_PIXELS = 630;
      var willCollapseToMenuButton = (windowWidth < TINY_DEVICE_WIDTH_PIXELS) ||
                                     ((SMALL_DEVICE_WIDTH_PIXELS <= windowWidth) &&
                                      (windowWidth < MEDIUM_DEVICE_WIDTH_PIXELS) &&
                                      $("#content_area").hasClass('has_multiple_feeds'));

      $(".horizontal_list_or_menu_button").toggleClass("btn-group", willCollapseToMenuButton);
      $(".horizontal_list_or_menu_button_items")
            .toggleClass("dropdown-menu", willCollapseToMenuButton)
            .toggleClass("horizontal-list", !willCollapseToMenuButton);
      if (willCollapseToMenuButton) {
         $(".menu_button").show();
      }
      else {
         $(".menu_button").hide();
      }

      // for small devices, make the channel switcher menu drop up
      $("#channel_switcher_menu").toggleClass("dropup", windowWidth < SMALL_DEVICE_WIDTH_PIXELS);

      // make the devices and feeds dropdown button smaller on tiny devices
      $("#devices_and_feeds_dropdown_menu_button").toggleClass("btn-sm", windowWidth < TINY_DEVICE_WIDTH_PIXELS);

      // When the window is tiny, the time range menu moves to the right, so we need to add the dropdown-menu-right Bootstrap CSS class
      $("#time_range_switcher_menu_items").toggleClass("dropdown-menu-right", windowWidth < TINY_DEVICE_WIDTH_PIXELS);
   }

   function setRangeFromSecondsAgoToNow(numSecondsAgo) {
      var now = Date.now() / 1000;
      var min = now - numSecondsAgo;
      plotManager.getDateAxis().constrainRangeTo(Math.min(min, selectedFeed.minTimeSecs), now);
      plotManager.getDateAxis().setRange(min, now);
   }

   // Mike has left you a pile of strange functions
   function drawBoxen(boxen, plotArea) {
      removeBoxen();
      var boxTemplate = Handlebars.templates['grapher_value_range_color_box'];
      boxen.levels.forEach(function(level, index) {
         var boxElement = boxTemplate({
            level : level,
            color : boxen.colors[index],
            zIndex : index - boxen.levels.length
         });
         $(plotArea).prepend(boxElement);
      })
   }

   function removeBoxen() {
      $('.color_box').remove();
   }

   function adjustBoxen(boxen, plotArea) {
      if (boxen.levels) {
         var axis = plotManager.getYAxis();
         var plotAreaElement = $(plotArea);
         boxen.levels.forEach(function(level) {
            var range = axis.getRange();
            $("#level_" + level)
                  .height((range.max - level) / (range.max - range.min) * plotAreaElement.height())
                  .css("max-height", plotAreaElement.height());
         });
      }
   }

   function sizeBoxen(boxen, plotArea, extra) {
      if (boxen.levels) {
         var plotAreaElement = $(plotArea);
         boxen.levels.forEach(function(level) {
            $("#level_" + level)
                  .width(plotAreaElement.width() + extra + 1)
                  .css("left", plotAreaElement.css("left"));
         });
      }
   }

</script>

<div id="dashboard_page">
   <div id="loading_panel">Loading...</div>
   <div id="has_no_devices_panel" style="display:none">
      <h2>Dashboard</h2>
      <p>
         You do not have any registered Specks. Please download and install our
         <a href="/support/software">Speck app</a> to register your Speck and configure it for uploads.
      </p>
   </div>
   <div id="has_no_feeds_panel" style="display:none">
      <h2>Dashboard</h2>
      <p>
         Your Speck has not yet uploaded any data. Once it has uploaded some data, you can explore it here.
      </p>
   </div>
   <div id="content_area" style="display:none">
      <div id="devices_and_feeds_sidebar_menu_container">
         <div class="title">My Specks</div>
         <div id="devices_and_feeds_sidebar_menu"></div>
      </div>
      <div id="grapher_container" class="noselect" style="display:none">
         <h2 id="page_title">Dashboard</h2>
         <div id="grapher_toolbar_top" class="grapher_toolbar">
            <div id="selected_device_and_feed_name_container">
               <div id="selected_device_and_feed_name_label" class="selected_device_and_feed_name">
                  <div class="device_name_label"></div>
                  <div class="feed_name_label"></div>
               </div>
               <div id="devices_and_feeds_dropdown_menu_container" class="dropdown">
                  <button id="devices_and_feeds_dropdown_menu_button" class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown" aria-expanded="true">
                     <div class="selected_device_and_feed_name">
                        <div class="device_name_label"></div>
                        <div class="feed_name_label"></div>
                     </div>
                     <span class="caret"></span>
                  </button>
                  <ul id="devices_and_feeds_dropdown_menu" class="dropdown-menu" role="menu" aria-labelledby="devices_and_feeds_dropdown_menu_button"></ul>
               </div>
            </div>
            <div id="time_range_switcher_menu" class="horizontal_list_or_menu_button btn-group">
               <button type="button" class="menu_button btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown" aria-expanded="false">
                  <i id="time_range_switcher_menu_icon" class="fa fa-clock-o"></i>
                  <span id="time_range_switcher_menu_label">Time Range</span>
                  <span id="time_range_switcher_menu_caret" class="caret"></span>
               </button>
               <ul id="time_range_switcher_menu_items" class="horizontal_list_or_menu_button_items dropdown-menu" role="menu"></ul>
            </div>
         </div>
         <table id="grapher" border="0" cellpadding="0" cellspacing="0">
            <tr>
               <td>
                  <div id="date_axis" class="date_axis"></div>
               </td>
               <td align="center" valign="bottom">
                  <div id="export_button_container" class="btn-group">
                     <button id="export_button" type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-expanded="false" title="Download your data">
                        <i class="fa fa-cloud-download"></i>
                     </button>
                     <ul id="export_button_menu" class="dropdown-menu dropdown-menu-right" role="menu">
                        <li><a id="export_this_channel_button" href="#">This Channel</a></li>
                        <li><a id="export_all_channels_button" href="#">All Channels</a></li>
                     </ul>
                  </div>
               </td>
            </tr>
            <tr>
               <td>
                  <div id="plot_container" class="plot_container" style="height:300px; border: 1px solid black;">
                     <div id="value_and_time"></div>
                  </div>
               </td>
               <td>
                  <div id="y_axis" class="y_axis" style="height:300px">
                     <div id="y_axis_label" class="rotate_90 y_axis_label">&nbsp;</div>
                  </div>
               </td>
            </tr>
            <tr>
               <td colspan="2" align="right">
                  <div id="grapher_toolbar_bottom" class="grapher_toolbar">
                     <div class="pull-left">
                        <div id="channel_switcher_menu" class="horizontal_list_or_menu_button btn-group">
                           <button type="button" class="menu_button btn btn-default btn-sm dropdown-toggle" data-toggle="dropdown" aria-expanded="false">
                              <span id="channel_switcher_menu_label"></span> <span class="caret"></span>
                           </button>
                           <ul id="channel_switcher_menu_items" class="horizontal_list_or_menu_button_items dropdown-menu" role="menu"></ul>
                        </div>
                     </div>

                     <div class="btn-group pull-right">
                        <a id="auto_scale_toggle_button" class="btn btn-default btn-sm active" href="#" onclick="toggleYAxisAutoScaling(); return false;" title="Toggle Y axis auto-scaling">Auto Scale</a>
                     </div>
                  </div>
               </td>
            </tr>
         </table>
      </div>
      <div id="map_area_container">
         <div id="map_area"></div>
         <div id="no_geolocation" class="noselect">You have not geolocated the selected feed.</div>
      </div>
   </div>
</div>
